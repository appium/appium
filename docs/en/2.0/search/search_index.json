{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Appium Documentation Welcome to the Appium documentation! Appium is an open-source project and ecosystem of related software, designed to facilitate UI automation of many app platforms, including mobile (iOS, Android, Tizen), browser (Chrome, Firefox, Safari), desktop (macOS, Windows), TV (Roku, tvOS, Android TV, Samsung), and more. If you're new to Appium, it's recommended that you start off with the Introduction , then move on to the Quickstart . And you can always find Appium's code on GitHub at appium/appium . What is Appium for? Appium is used mostly in the field of software test automation, to help determine whether the functionality of a given app is working as expected. In contrast to other types of software testing, UI automation allows testers to write code that walks through user scenarios in the actual UI of an application, mimicking as closely as possible what happens in the real world while enabling the various benefits of automation, including speed, scale, and consistency. Appium aims to provide a set of tools that support this kind of automation in a standard way across any number of platforms. Most platforms come with tools that allow UI automation at some level, but these are usually platform-specific and require specialized knowledge and specific programming language experience and toolchains. Appium tries to unify all these automation technology under a single stable interface, accessible via most popular programming languages (you can write Appium scripts in Java, Python, Ruby, JS, and more). To learn more about how Appium accomplishes this goal, and the various components involved, have a read through our Introduction . Learning Appium This documentation is a great way to learn more about Appium: Check out the Introduction first to make sure you understand all the concepts involved in Appium. Go through the Quickstart to get set up and run a basic Android test. Have a look at the various guides and references. Using Appium for a real project means using an Appium driver for a specific platform, so you'll want to have a look at the Ecosystem page where we keep links to the drivers and plugins you might want to use; you can refer to those projects for specific information about using Appium for a given platform. You can also check out a list of third-party Resources to explore Appium around the web. Contributing to Appium Appium is open source, available under an Apache 2.0 license. Appium's copyright is held by the OpenJS Foundation , and Appium receives contributions from many companies across several software industries, regardless of their competitive status. (3rd-party drivers and plugins are available under the licenses provided by their authors.) As such, we welcome contributions! The project moves forward in relation to the investment of contributions of code, documentation, maintenance, and support from companies and volunteers. To learn more about contributing, check out our GitHub repo at appium/appium and read through our Contributing guides.","title":"Welcome"},{"location":"#appium-documentation","text":"Welcome to the Appium documentation! Appium is an open-source project and ecosystem of related software, designed to facilitate UI automation of many app platforms, including mobile (iOS, Android, Tizen), browser (Chrome, Firefox, Safari), desktop (macOS, Windows), TV (Roku, tvOS, Android TV, Samsung), and more. If you're new to Appium, it's recommended that you start off with the Introduction , then move on to the Quickstart . And you can always find Appium's code on GitHub at appium/appium .","title":"Appium Documentation"},{"location":"#what-is-appium-for","text":"Appium is used mostly in the field of software test automation, to help determine whether the functionality of a given app is working as expected. In contrast to other types of software testing, UI automation allows testers to write code that walks through user scenarios in the actual UI of an application, mimicking as closely as possible what happens in the real world while enabling the various benefits of automation, including speed, scale, and consistency. Appium aims to provide a set of tools that support this kind of automation in a standard way across any number of platforms. Most platforms come with tools that allow UI automation at some level, but these are usually platform-specific and require specialized knowledge and specific programming language experience and toolchains. Appium tries to unify all these automation technology under a single stable interface, accessible via most popular programming languages (you can write Appium scripts in Java, Python, Ruby, JS, and more). To learn more about how Appium accomplishes this goal, and the various components involved, have a read through our Introduction .","title":"What is Appium for?"},{"location":"#learning-appium","text":"This documentation is a great way to learn more about Appium: Check out the Introduction first to make sure you understand all the concepts involved in Appium. Go through the Quickstart to get set up and run a basic Android test. Have a look at the various guides and references. Using Appium for a real project means using an Appium driver for a specific platform, so you'll want to have a look at the Ecosystem page where we keep links to the drivers and plugins you might want to use; you can refer to those projects for specific information about using Appium for a given platform. You can also check out a list of third-party Resources to explore Appium around the web.","title":"Learning Appium"},{"location":"#contributing-to-appium","text":"Appium is open source, available under an Apache 2.0 license. Appium's copyright is held by the OpenJS Foundation , and Appium receives contributions from many companies across several software industries, regardless of their competitive status. (3rd-party drivers and plugins are available under the licenses provided by their authors.) As such, we welcome contributions! The project moves forward in relation to the investment of contributions of code, documentation, maintenance, and support from companies and volunteers. To learn more about contributing, check out our GitHub repo at appium/appium and read through our Contributing guides.","title":"Contributing to Appium"},{"location":"resources/","text":"Here you can find links to additional Appium resources around the web: Websites Appium Pro - a blog and newsletter written by one of Appium's maintainers, Jonathan Lipps, with lots of useful guides Online Courses Appium and Selenium Fundamentals - a comprehensive video course on learning Python, Selenium, and Appium by Jonathan Lipps Mobile Test Automation with Appium - a video course by Moataz Nabil Advanced Appium - a video course by Jonathan Lipps","title":"More Appium Resources"},{"location":"resources/#websites","text":"Appium Pro - a blog and newsletter written by one of Appium's maintainers, Jonathan Lipps, with lots of useful guides","title":"Websites"},{"location":"resources/#online-courses","text":"Appium and Selenium Fundamentals - a comprehensive video course on learning Python, Selenium, and Appium by Jonathan Lipps Mobile Test Automation with Appium - a video course by Moataz Nabil Advanced Appium - a video course by Jonathan Lipps","title":"Online Courses"},{"location":"cli/","text":"TODO","title":"CLI Intro"},{"location":"cli/args/","text":"To start the Appium server, you may either run appium or appium server . The server subcommand is considered to be the default, so if you omit it, Appium will interpret this as your request to run the Appium server. (You could run different subcommands, like appium driver or appium plugin : see the Extensions CLI for more info). The invocation of appium (or appium server ) takes a number of arguments, which are detailed below. Note All of these arguments can be set via a Configuration File instead if you want. Any arguments set on the command line will override any arguments found in a configuration file. Argument Description Type Default Aliases --address IP address to listen on string 0.0.0.0 -a --allow-cors Whether the Appium server should allow web browser connections from any host boolean false --allow-insecure Set which insecure features are allowed to run in this server's sessions. Features are defined on a driver level; see documentation for more details. Note that features defined via \"deny-insecure\" will be disabled, even if also listed here. If string, a path to a text file containing policy or a comma-delimited list. array [] --base-path Base path to use as the prefix for all webdriver routes running on the server string \"\" -pa --callback-address Callback IP address (default: same as \"address\") string -ca --callback-port Callback port (default: same as \"port\") (Value must be between 1 and 65535 ) integer 4723 -cp --debug-log-spacing Add exaggerated spacing in logs to help with visual inspection boolean false --default-capabilities Set the default desired capabilities, which will be set on each session unless overridden by received capabilities. If a string, a path to a JSON file containing the capabilities, or raw JSON. object -dc --deny-insecure Set which insecure features are not allowed to run in this server's sessions. Features are defined on a driver level; see documentation for more details. Features listed here will not be enabled even if also listed in \"allow-insecure\", and even if \"relaxed-security\" is enabled. If string, a path to a text file containing policy or a comma-delimited list. array [] --driver Driver-specific configuration. Keys should correspond to driver package names object --keep-alive-timeout Number of seconds the Appium server should apply as both the keep-alive timeout and the connection timeout for all requests. A value of 0 disables the timeout. integer 600 -ka --local-timezone Use local timezone for timestamps boolean false --log Also send log output to this file string -g --log-filters One or more log filtering rules array --log-level Log level (console[:file]) (Value must be one of: info , info:debug , info:info , info:warn , info:error , warn , warn:debug , warn:info , warn:warn , warn:error , error , error:debug , error:info , error:warn , error:error , debug , debug:debug , debug:info , debug:warn , debug:error ) string debug --log-no-colors Do not use color in console output boolean false --log-timestamp Show timestamps in console output boolean false --long-stacktrace Add long stack traces to log entries. Recommended for debugging only. boolean false --no-perms-check Do not check that needed files are readable and/or writable boolean false --nodeconfig Path to configuration JSON file to register Appium as a node with Selenium Grid 3; otherwise the configuration itself object --plugin Plugin-specific configuration. Keys should correspond to plugin package names object --port Port to listen on (Value must be between 1 and 65535 ) integer 4723 -p --relaxed-security Disable additional security checks, so it is possible to use some advanced features, provided by drivers supporting this option. Only enable it if all the clients are in the trusted network and it's not the case if a client could potentially break out of the session sandbox. Specific features can be overridden by using \"deny-insecure\" boolean false --session-override Enables session override (clobbering) boolean false --strict-caps Cause sessions to fail if desired caps are sent in that Appium does not recognize as valid for the selected device boolean false --tmp Absolute path to directory Appium can use to manage temp files. Defaults to C:\\Windows\\Temp on Windows and /tmp otherwise. string --trace-dir Absolute path to directory Appium can use to save iOS instrument traces; defaults to /appium-instruments string --use-drivers A list of drivers to activate. By default, all installed drivers will be activated. array [] --use-plugins A list of plugins to activate. To activate all plugins, the value should be an array with a single item \"all\". array [] --webhook Also send log output to this http listener string -G","title":"Server CLI Args"},{"location":"cli/extensions/","text":"Appium allows for the flexible installation and management of drivers (which provide Appium with the capability to automate a given platform) and plugins (which can augment or alter the way individual Appium commands work). For a conceptual understanding of these entities, please review the Introduction . Management of drivers and plugins is handled by Appium's Extension CLI. Note This reference uses placeholders to refer to various options. Anywhere you see one of these placeholders in the reference, ensure you replace it with the correct type of actual content. Placeholder Meaning <ext-type> \"Extension type\". It should be either driver or plugin . All the Extension CLI commands can be used with either drivers or plugins, so you must specify which type of extension will be used <ext-name> \"Extension name\". This is the short name of the extension found in a call to appium <ext-type> list . This is distinct from the NPM package name of the extension or, in general, the \"install spec\" of the extension. <install-spec> \"Install specification\". This refers to the string used to indicate what extension Appium should install. <install-source> This refers to the method that Appium should use to install an extension. Commands All Extension CLI commands begin with appium <ext-type> , i.e., either appium driver or appium plugin . All Extension CLI commands can take an optional --json argument, which will return the result of the command as a machine-readable JSON string rather than the standard output, which is colourized and tuned for human consumption. list List installed and available extensions. \"Available\" extensions include those which are officially recognized by the Appium team, but you are not limited to installing only the extensions displayed in this list. Usage: appium <ext-type> list [--installed] [--updates] [--json] Required arguments: <ext-type> : must be driver or plugin Optional arguments: --installed : show only installed extensions, not installed plus available extensions --updates : for extensions installed via NPM, display a message if there are any updates --json : return the result in JSON format install Install an extension. If successful, respond with the short name of the extension which can be used in other invocations of the Extension CLI. If the extension is a driver, also note which platforms may be used with the driver. Usage: appium <ext-type> install <install-spec> [--source=<install-source>] [--package=<package-name>] [--json] Required arguments: <ext-type> : must be driver or plugin <install-spec> : this is the name, location, and/or version of the extension you want to install. Its possible values are dependent on the <install-source> (see below). Optional arguments: --source : this directs Appium where to find your extension. See below for a table of possible source types and corresponding install specification. --package : when <install-source> is git or github , --package is required. It should be the Node.js package name of the extension. Without this information, Appium will not be able to find the installed package. --json : return the result in JSON format Install source type Behaviour None This is the default behaviour when no --source is used. In this case, Appium will look at <install-spec> and match it against the name of extensions available when running appium <ext-type> list , i.e., against the officially recognized extension names. If found, it will install that extension at the latest version via NPM npm Install an extension based on its NPM package name. Here, <install-spec> must be the NPM package name with any additional NPM installation modifiers, like version (see below) github Install an extension via a GitHub spec of the form <org>/<repo> git Install an extension via a Git URL (e.g., git+ssh://git-host.com/repo.git ) local Install an extension via a local path. This must be a path to the directory where the Node.js package information for the driver is located. NPM-based <install-spec> When Appium is installing an extension via NPM (as is the case when --source is either omitted or set to npm ), the <install-spec> can be complex, and can include any kind of information allowed by npm install : [@scope]/<name> [@scope]/<name>@<version> [@scope]/<name>@<tag> [@scope]/<name>@<version range> Examples Install the latest XCUITest driver: appium driver install xcuitest Install the XCUITest driver at version 4.11.1: appium driver install xcuitest@4.11.1 Install the beta version of the @appium/fake-driver from NPM: appium driver install --source=npm @appium/fake-driver@beta Install a locally-developed plugin: appium plugin install --source=local /path/to/my/plugin update Update one or more extensions that have been installed via NPM. By default, Appium will not automatically update any extension that has a revision in its major version, so as to prevent unintended breaking changes. Usage: appium <ext-type> update <ext-name> [--unsafe] [--json] Required arguments: <ext-type> : must be driver or plugin <ext-name> : the name of the extension to update, or the string installed (which will update all installed extensions) Optional arguments: --unsafe : direct Appium to go ahead and update passed a major version boundary --json : return the result in JSON format uninstall Remove an installed extension. Usage: appium <ext-type> uninstall <ext-name> [--json] Required arguments: <ext-type> : must be driver or plugin <ext-name> : the name of the extension to uninstall Optional arguments: --json : return the result in JSON format run Run a script included in an extension package. Extension authors can include runnable scripts that assist with setup or perform other tasks. These scripts are given names (called the <script-name> in this reference) by extension authors and will generally be documented in extension documentation. Usage: appium <ext-type> run <ext-name> [--json] <script-name> [script-args] Required arguments: <ext-type> : must be driver or plugin <ext-name> : the name of the extension whose script you want to run <script-name> : the name of the script the extension has published Optional arguments: script-args : any arguments that Appium does not interpret as belonging to its own set of arguments will be passed along to the extension script --json : return the result in JSON format Example (run the reset script included with the UiAutomator2 driver): appium driver run uiautomator2 reset","title":"The Extension CLI"},{"location":"cli/extensions/#commands","text":"All Extension CLI commands begin with appium <ext-type> , i.e., either appium driver or appium plugin . All Extension CLI commands can take an optional --json argument, which will return the result of the command as a machine-readable JSON string rather than the standard output, which is colourized and tuned for human consumption.","title":"Commands"},{"location":"cli/extensions/#list","text":"List installed and available extensions. \"Available\" extensions include those which are officially recognized by the Appium team, but you are not limited to installing only the extensions displayed in this list. Usage: appium <ext-type> list [--installed] [--updates] [--json] Required arguments: <ext-type> : must be driver or plugin Optional arguments: --installed : show only installed extensions, not installed plus available extensions --updates : for extensions installed via NPM, display a message if there are any updates --json : return the result in JSON format","title":"list"},{"location":"cli/extensions/#install","text":"Install an extension. If successful, respond with the short name of the extension which can be used in other invocations of the Extension CLI. If the extension is a driver, also note which platforms may be used with the driver. Usage: appium <ext-type> install <install-spec> [--source=<install-source>] [--package=<package-name>] [--json] Required arguments: <ext-type> : must be driver or plugin <install-spec> : this is the name, location, and/or version of the extension you want to install. Its possible values are dependent on the <install-source> (see below). Optional arguments: --source : this directs Appium where to find your extension. See below for a table of possible source types and corresponding install specification. --package : when <install-source> is git or github , --package is required. It should be the Node.js package name of the extension. Without this information, Appium will not be able to find the installed package. --json : return the result in JSON format Install source type Behaviour None This is the default behaviour when no --source is used. In this case, Appium will look at <install-spec> and match it against the name of extensions available when running appium <ext-type> list , i.e., against the officially recognized extension names. If found, it will install that extension at the latest version via NPM npm Install an extension based on its NPM package name. Here, <install-spec> must be the NPM package name with any additional NPM installation modifiers, like version (see below) github Install an extension via a GitHub spec of the form <org>/<repo> git Install an extension via a Git URL (e.g., git+ssh://git-host.com/repo.git ) local Install an extension via a local path. This must be a path to the directory where the Node.js package information for the driver is located.","title":"install"},{"location":"cli/extensions/#npm-based-install-spec","text":"When Appium is installing an extension via NPM (as is the case when --source is either omitted or set to npm ), the <install-spec> can be complex, and can include any kind of information allowed by npm install : [@scope]/<name> [@scope]/<name>@<version> [@scope]/<name>@<tag> [@scope]/<name>@<version range>","title":"NPM-based &lt;install-spec&gt;"},{"location":"cli/extensions/#examples","text":"Install the latest XCUITest driver: appium driver install xcuitest Install the XCUITest driver at version 4.11.1: appium driver install xcuitest@4.11.1 Install the beta version of the @appium/fake-driver from NPM: appium driver install --source=npm @appium/fake-driver@beta Install a locally-developed plugin: appium plugin install --source=local /path/to/my/plugin","title":"Examples"},{"location":"cli/extensions/#update","text":"Update one or more extensions that have been installed via NPM. By default, Appium will not automatically update any extension that has a revision in its major version, so as to prevent unintended breaking changes. Usage: appium <ext-type> update <ext-name> [--unsafe] [--json] Required arguments: <ext-type> : must be driver or plugin <ext-name> : the name of the extension to update, or the string installed (which will update all installed extensions) Optional arguments: --unsafe : direct Appium to go ahead and update passed a major version boundary --json : return the result in JSON format","title":"update"},{"location":"cli/extensions/#uninstall","text":"Remove an installed extension. Usage: appium <ext-type> uninstall <ext-name> [--json] Required arguments: <ext-type> : must be driver or plugin <ext-name> : the name of the extension to uninstall Optional arguments: --json : return the result in JSON format","title":"uninstall"},{"location":"cli/extensions/#run","text":"Run a script included in an extension package. Extension authors can include runnable scripts that assist with setup or perform other tasks. These scripts are given names (called the <script-name> in this reference) by extension authors and will generally be documented in extension documentation. Usage: appium <ext-type> run <ext-name> [--json] <script-name> [script-args] Required arguments: <ext-type> : must be driver or plugin <ext-name> : the name of the extension whose script you want to run <script-name> : the name of the script the extension has published Optional arguments: script-args : any arguments that Appium does not interpret as belonging to its own set of arguments will be passed along to the extension script --json : return the result in JSON format Example (run the reset script included with the UiAutomator2 driver): appium driver run uiautomator2 reset","title":"run"},{"location":"contributing/","text":"This section of Appium's documentation is for those who are interested in contributing to Appium's development. It contains developer overviews, guides, and notes. Use the navigation menu to find a specific topic. All the information in these guides assumes in-depth familiarity with Appium already. Warning Developer information may not be kept up to date as frequently as user-facing information, or it may be most relevant in its current form on the online repository, not in this published version. Always be sure to check the repo or discuss with maintainers. We're always happy to help new contributors get started! Ways to Contribute TODO The Appium Development Process TODO","title":"Contributing to Appium"},{"location":"contributing/#ways-to-contribute","text":"TODO","title":"Ways to Contribute"},{"location":"contributing/#the-appium-development-process","text":"TODO","title":"The Appium Development Process"},{"location":"contributing/config-system/","text":"Appium 2 supports configuration files . A configuration file is intended to have (nearly) 1:1 parity with command-line arguments. An end user can supply Appium 2 with a configuration file, CLI args, or both (the args have precedence over the config file). This document will be a technical overview of how the configuration system works. It is intended for Appium contributors, but will also explain the system's fundamental features. Reading a Config File A config file is a JSON, JavaScript, or YAML file which can be validated against a schema. By default, this file will be named .appiumrc.{json,js,yaml,yml} and should be in the root of the project which depends upon appium . Other filenames and locations are supported via the --config <file> flag. For obvious reasons, the config argument is disallowed within config files. In lieu of a separate file, configuration can be embedded in a project's package.json using the appiumConfig property, e.g.,: { \"appiumConfig\" : { \"server\" : { \"port\" : 12345 } } } When an Appium server is started via the appium executable, the init function in lib/main.js will call into lib/config-file.js to load and/or search for a configuration file and in package.json . Note It is not an error if configuration isn't found! The lilconfig package provides the search & load functionality; refer to its documentation for more information about the search paths. Additionally, Appium provides support for config files written in YAML via the package yaml . If a config file is found and successfully validated , the result will be merged with a set of defaults and any additionall CLI arguments. CLI arguments have precedence over config files, and config files have precedence over defaults. Validation The same system is used for both validation of config files and command-line arguments. The package ajv provides validation. Of course, to make ajv validate anything, it must be provided a schema . The base schema is a JSON Schema Draft-7 -compliant object exported by lib/schema/appium-config-schema.js . This schema defines configuration native to Appium , and only concerns its behavior as a server ; it does not define configuration for any other functionality (e.g., the plugin or driver subcommands). Warning Note that this file is the base schema; this will become painfully relevant. This file is is not a JSON file, because a) JSON is painful to work with for humans, b) is especially reviled by @jlipps, and c) ajv accepts objects, not JSON files. It is more straightforward to explain how config files are validated, so we'll start there. Validating Config Files When a config file is found ( lib/config-file.js ), it will call the validate function exported from lib/schema/schema.js with the contents of the config file. In turn, this asks ajv to validate the data against the schema that Appium has provided it. If the config file is invalid, errors will be generated to be displayed to the user. Finally, the init function will detect these errors, display them, and the process will exit. I hope that made sense, because this is the easy part. Validating CLI Arguments As mentioned earlier, the same system is used for validating both config files and CLI arguments. Totally not judging, but Appium uses argparse for its CLI argument parsing. This package, and others like it, provides an API to define the arguments a command-line Node.js script accepts, and will ultimately return an object representation of the user-supplied arguments. Just as the schema defines what's allowed in a config file, it also defines what's allowed on the command-line. Defining CLI Arguments via Schema CLI arguments must be defined before their values can be validated. A JSON schema isn't a natural fit for defining CLI args--it needs some grease to make it work--but it's close enough that we can do so with an adapter and some custom metadata. In lib/cli/parser.js , there's a wrapper around argparse 's ArgumentParser ; it's called (wait for it)... ArgParser . The wrapper exists because we're doing some custom things with argparse , but is has nothing to do with the schema directly. An ArgParser instance is created and its parseArgs() method is called with the raw CLI arguments. The definition of the accepted arguments comes from lib/cli/args.js in part--here, all of the arguments not intended for use with the server subcommand are hard-coded (e.g., the driver subcommand and its subcommands). args.js also contains a function getServerArgs() , which in turn calls into toParserArgs in lib/schema/cli-args.js . lib/schema/cli-args.js can be considered the \"adapter\" layer between argparse and the schema. toParserArgs uses the flattenSchema function exported by lib/schema/schema.js , which \"squashes\" the schema into a key/value representation. Then, toParserArgs iterates over each key/value pair and \"converts\" it into a suitable ArgumentOption object for final handoff to ArgParser . This adapter ( cli-args.js ) is where most of the mess is hidden; let's explore this rat's nest a bit further. CLI & Schema Incongruities The conversion algorithm (see function subSchemaToArgDef in lib/schema/cli-args.js ) is mostly just hacks and special cases neatly packed into a function. Things that don't cleanly map from argparse to a JSON schema include, but are not limited to: A schema cannot natively express \"store the value of --foo=<value> in a property called bar \" in a schema (this corresponds to the ArgumentOption['dest'] prop). A schema cannot natively express aliases; e.g., --verbose can also be -v A schema enum is not restricted to multiple types, but argparse 's equivalent ArgumentOption['choices'] prop is A schema does not know about argparse 's concept of \"actions\" (note that Appium is not currently using custom actions--though it did, and it could again). argparse has no native type for email , hostname , ipv4 , uri etc., and the schema does Schema validation only validates , it does not perform translation, transformation, or coercion (mostly). argparse allows this. Schemas allow the null type, for whatever reason. Ever pass null on the CLI? argparse does not understand anything other than primitives; no objects, arrays, etc., and certainly not arrays of a particular type. All of the above cases and others are handled by the adapter. Warning Some decisions made in the adapter were arrived at via coin toss. If you are curious about why something is the way it is, it's likely that it had to do something . Let's look more closely at handling types. Argument Types via ajv While argparse allows consumers, via its API, to define the type of various arguments (e.g., a string, number, boolean flag, etc.), Appium mostly avoids these built-in types. Why is that? Well: We already know the type of an argument, because we've defined it in a schema. ajv provides validation against a schema. A schema allows for greater expression of types, allowed values, etc., than argparse can provide natively. The expressiveness of a schema allows for better error messaging. To that end, the adapter eschews argparse 's built-in types (see allowed string values of ArgumentOption['type'] ) and instead abuses the ability to provide a function as a type . The exception is boolean flags, which do not have a type , but rather action: 'store_true' . The world may never know why. Types as Functions When a type is a function, the function performs both validation and coercion (if necessary). So what are these functions? Note: type is omitted (and thus not a function) from the ArgumentOption if the property type is boolean , and is instead provided an action property of store_true . Yes, this is weird. No, I don't know why. Well... it depends upon the schema. But generally speaking, we create a pipeline of functions, each corresponding to a keyword in the schema. Let's take the example of the port argument. In lieu of asking the OS which ports the appium -running user can bind to, this argument is expected to be an integer between 1 and 65535. This turns out to be two functions which we combine into a pipeline: Convert the value to an integer, if possible. Because every value in process.argv is a string , we must coerce if we want a number. Use ajv to validate the integer against the schema for port . A schema lets us define a range via the minimum and maximum keywords. Read more about how this works in Much like the config file validation, if errors are detected, Appium nicely tells the end-user and the process exits w/ some help text. For other arguments which are naturally of non-primitive types, things are not so straightforward. Transformers Remember how argparse doesn't understand arrays? What if the most ergonomic way to express a value is, in fact, an array? Well, Appium can't accept an array on the CLI, even though it can accept one in the config file. But Appium can accept a comma-delimited string (a CSV \"line\"). Or a string filepath referring to a file which contains a delimited list. Either way: by the time the value gets out of the argument parser, it should be an array. And as mentioned above, the native facilities of a JSON schema cannot express this. However, it's possible to define a custom keyword which Appium can then detect and handle accordingly. So that's what Appium does. In this case, a custom keyword appiumCliTransformer is registered with ajv . The value of appiumCliTransformer (at the time of this writing) can be csv or json . In the base schema file, appium-config-schema.js , Appium uses appiumCliTransformer: 'csv' if this behavior is desired. Note Any property defined in the schema having type array will automatically uses the csv transformer. Likewise, a property having type object will use the json transformer. It's conceivable that array may want to use the json transformer, but otherwise, the presence of the appiumCliTransformer keyword on an array -or- object -typed property is not stricly necessary. The adapter (remember the adapter?) creates a pipeline function including a special \"CSV transformer\" (transformers are defined in lib/schema/cli-transformers.js ), and uses this function as the type property of the ArgumentOption passed into argparse . In this case, the type: 'array' in the schema is ignored. Note The config file doesn't need to perform any complex transformation of values, because it naturally allows Appium to define exactly what it expects. So Appium does no post-processing of config file values. Properties that do not need this special treatment use ajv directly for validation. How this works requires some explanation, so that's next. Validation of Individual Arguments via ajv When we think of a JSON schema, we tend to think, \"I have this JSON file and I want to validate it against the schema\". That's valid, and in fact Appium does just that with config files! However, Appium does not do this when validating arguments. Note During implementation, I was tempted to mash all of the arguments together into a config-file-like data structure and then validate it all at once. I think that would have been possible , but since an object full of CLI arguments is a flat key/value structure and the schema is not, this seemed like trouble. Instead, Appium validates a value against a specific property within the schema. To do this, it maintains a mapping between a CLI argument definition and its corresponding property. The mapping itself is a Map with a unique identifier for the argument as the key, and an ArgSpec ( lib/schema/arg-spec.js ) object as the value. An ArgSpec object stores the following metadata: Property Name Description name Canonical name of the argument, corresponding to the property name in the schema. extType? driver or plugin , if appropriate extName? Extension name, if appropriate ref Computed $id of the property in the schema arg Argument as accepted on CLI, without leading dashes dest Property name in parsed arguments object (as returned by argparse 's parse_args() ) defaultValue? Value of the default keyword in schema, if appropriate When a schema is finalized , the Map is populated with ArgSpec objects for all known arguments. So when the adapter is creating the pipeline of functions for the argument's type , it already has an ArgSpec for the argument. It creates a function which calls validate(value, ref) (in lib/schema/schema.js ) where value is whatever the user provided, and ref is the ref property of the ArgSpec . The concept is that ajv can validate using any ref it knows about; each property in a schema can be referenced by this ref whether it's defined or not. To help visualize, if a schema is: { \"$id\" : \"my-schema.json\" , \"type\" : \"object\" , \"properties\" : { \"foo\" : { \"type\" : \"number\" } } } The ref of foo would be my-schema.json#/properties/foo . Assuming our Ajv instance knows about this my-schema.json , then we can call its getSchema(ref) method (which has a schema property, but is a misnomer nonetheless) to get a validation function; validate(value, ref) in schema.js calls this validation function. Note The schema spec says a schema author can supply an explicit $id keyword to override this; it's unsupported by Appium at this time. If needed, extension authors must carefully use $ref without custom $id s. It's highly unlikely an extension would have a schema so complicated as to need this, however; Appium itself doesn't even use $ref to define its own properties! Next, let's take a look at how Appium loads schemas. This actually happens before any argument validation. Schema Loading Let's ignore extensions for a moment, and start with the base schema. When something first imports the lib/schema/schema.js module, an instance of an AppiumSchema is created. This is a singleton, and its methods are exported from the module (all of which are bound to the instance). The constructor does very little; it instantiates an Ajv instance and configures it with Appium's custom keywords and adds support for the format keyword via the ajv-formats module. Otherwise, the AppiumSchema instance does not interact with the Ajv instance until its finalize() method (exported as finalizeSchema() ) is called. When this method is called, we're saying \"we are not going to add any more schemas; go ahead and create ArgSpec objects and register schemas with ajv \". When does finalization happen? Well: When the appium executable begins, it checks for and configures extensions (hand-wave) in APPIUM_HOME . Only then does it start to think about arguments--it instantiates an ArgParser , which (as you'll recall) runs the adapter to convert the schema to arguments. Finalization happens here --when creating the parser. Appium need the schema(s) to be registered with ajv in order to create validation functions for arguments. Thereafter, Appium parses the arguments with the ArgParser . Finally, decides what to do with the returned object. Without extensions, finalize() still knows about the Appium base schema ( appium-config-schema.js ), and just registers that. However, step 1. above is doing a lot of work , so let's look at how extensions come into play. Extension Support One of the design goals of this system is the following: An extension should be able to register custom CLI arguments with the Appium, and a user should be able to use them like any other argument . Previously, Appium 2.0 accepted arguments in this manner (via --driverArgs ), but validation was hand-rolled and required extension implementors to use a custom API. It also required the user to awkwardly pass a JSON string as the configuration on the command-line. Further, no contextual help (via --help ) existed for these arguments. Now, by providing a schema for its options, a driver or plugin can register CLI arguments and config file schemas with Appium. To register a schema, an extension must provide the appium.schema property in its package.json . The value may be a schema or a path to a schema. If the latter, the schema should be JSON or a CommonJS module (ESM not supported at this time, nor is YAML). For any property in this schema, the property will appear as a CLI argument of the form --<extension-type>-<extension-name>-<property-name> . For example, if the fake driver provides a property foo , the argument will be --driver-fake-foo , and will show in appium server --help like any other CLI argument. The corresponding property in a config file would be server.<extension-type>.<extension-name>.<property-name> , e.g.: { \"server\" : { \"driver\" : { \"fake\" : { \"foo\" : \"bar\" } } } } The naming convention described above avoids problems of one extension type having a name conflict with a different extension type. Note While an extension can provide aliases via appiumCliAliases , \"short\" flags are disallowed, since all arguments from extensions are prefixed with --<extension-type>-<extension-name>- . The extension name and argument name will be kebab-cased for the CLI, according to Lodash's rules around kebab-casing. The schema object will look much like Appium's base schema, but it will only have top-level properties (nested properties are currently unsupported). Example: { \"title\" : \"my rad schema for the cowabunga driver\" , \"type\" : \"object\" , \"properties\" : { \"fizz\" : { \"type\" : \"string\" , \"default\" : \"buzz\" , \"$comment\" : \"corresponds to CLI --driver-cowabunga-fizz\" } } } As written in a user's config file, this would be the server.driver.cowabunga.fizz property. When extensions are loaded, the schema property is verified and the schema is registered with the AppiumSchema (it is not registered with Ajv until finalize() is called). During finalization, each registered schema is added to the Ajv instance. The schema is assigned an $id based on the extension type and name (which overrides whatever the extension provides, if anything). Schemas are also forced to disallowed unknown arguments via the additionalProperties: false keyword. Behind the scenes, the base schema has driver and plugin properties which are objects. When finalized, a property is added to each--corresponding to an extension name--and the value of this property is a reference to the $id of a property in the extension schema. For example, the server.driver property will look like this: { \"driver\" : { \"cowabunga\" : { \"$ref\" : \"driver-cowabunga.json\" } } } This is why we call it the \"base\" schema--it is mutated when extensions provide schemas. The extension schemas are kept separately, but the references are added to the schema before it's ultimately added to ajv . This works because an Ajv instance understands references from any schema it knows about to any schema it knows about. Note This makes it impossible to provide a complete static schema for Appium and the installed extensions (as of Nov 5 2021). A static .json schema is generated from the base (via a Gulp task), but it does not contain any extension schemas. The static schema also has uses beyond Appium; e.g., IDEs can provide contextual error-checking of config files this way. Let's solve this? Just like how we look up the reference ID of a particular argument in the base schema, validation of arguments from extensions happens the exact same way. If the cowabunga driver has the schema ID driver-cowabunga.json , then the fizz property can be referenced from any schema registered with ajv via driver-cowabunga.json#/properties/fizz . \"Base\" schema arguments begin with appium.json#properties/ instead. Development Environment Support During the flow of development, a couple extra tasks have been automated to maintain the base schema: As a post-transpilation step, a lib/appium-config.schema.json gets generated from lib/schema/appium-config-schema.js (in addition to its CJS counterpart generated by Babel). This file is under version control. It ends up being copied to build/lib/appium-config.schema.json in this step. A pre-commit hook (see scripts/generate-schema-declarations.js in the root monorepo) generates a types/appium-config-schema.d.ts from the above JSON file. The types in types/types.d.ts depend upon this file. This file is under version control. Custom Keyword Reference Keywords are defined in lib/schema/keywords.js . appiumCliAliases : allows a schema to express aliases (e.g., a CLI argument can be --verbose or -v ). This is an array of strings. Strings shorter than three (3) characters will begin with a single dash ( - ) instead of a double-dash ( -- ). Note that any argument provided by an extension will begin with a double-dash, because these are required to have the --<extension-type>-<extension-name>- prefix. appiumCliDest : allows a schema to specify a custom property name in the post- argprase arguments objects. If not set, this becomes a camelCased string. appiumCliDescription : allows a schema to override the description of the argument when displayed on the command-line. This is useful paired with appiumCliTransformer (or array / object -typed properties), since there's a substantial difference between what a CLI-using user can provide vs. what a config-file-using user can provide. appiumCliTransformer : currently a choice between csv and json . These are custom functions which post-process a value. They are not used when loading & validating config files, but the idea should be that they result in the same object you'd get if you used whatever the config file wanted (e.g., an array of strings). csv is for comma-delimited strings and CSV files; json is for raw JSON strings and .json files. appiumCliIgnore : If true , do not support this property on the CLI. appiumDeprecated : If true , the property is considered \"deprecated\", and will be displayed as such to the user (e.g., in the --help output). Note the JSON Schema draft-2019-09 introduces a new keyword deprecated which we should use instead if upgrading to this metaschema. When doing so, appiumDeprecated should itself be marked as deprecated .","title":"Appium's Config System"},{"location":"contributing/config-system/#reading-a-config-file","text":"A config file is a JSON, JavaScript, or YAML file which can be validated against a schema. By default, this file will be named .appiumrc.{json,js,yaml,yml} and should be in the root of the project which depends upon appium . Other filenames and locations are supported via the --config <file> flag. For obvious reasons, the config argument is disallowed within config files. In lieu of a separate file, configuration can be embedded in a project's package.json using the appiumConfig property, e.g.,: { \"appiumConfig\" : { \"server\" : { \"port\" : 12345 } } } When an Appium server is started via the appium executable, the init function in lib/main.js will call into lib/config-file.js to load and/or search for a configuration file and in package.json . Note It is not an error if configuration isn't found! The lilconfig package provides the search & load functionality; refer to its documentation for more information about the search paths. Additionally, Appium provides support for config files written in YAML via the package yaml . If a config file is found and successfully validated , the result will be merged with a set of defaults and any additionall CLI arguments. CLI arguments have precedence over config files, and config files have precedence over defaults.","title":"Reading a Config File"},{"location":"contributing/config-system/#validation","text":"The same system is used for both validation of config files and command-line arguments. The package ajv provides validation. Of course, to make ajv validate anything, it must be provided a schema . The base schema is a JSON Schema Draft-7 -compliant object exported by lib/schema/appium-config-schema.js . This schema defines configuration native to Appium , and only concerns its behavior as a server ; it does not define configuration for any other functionality (e.g., the plugin or driver subcommands). Warning Note that this file is the base schema; this will become painfully relevant. This file is is not a JSON file, because a) JSON is painful to work with for humans, b) is especially reviled by @jlipps, and c) ajv accepts objects, not JSON files. It is more straightforward to explain how config files are validated, so we'll start there.","title":"Validation"},{"location":"contributing/config-system/#validating-config-files","text":"When a config file is found ( lib/config-file.js ), it will call the validate function exported from lib/schema/schema.js with the contents of the config file. In turn, this asks ajv to validate the data against the schema that Appium has provided it. If the config file is invalid, errors will be generated to be displayed to the user. Finally, the init function will detect these errors, display them, and the process will exit. I hope that made sense, because this is the easy part.","title":"Validating Config Files"},{"location":"contributing/config-system/#validating-cli-arguments","text":"As mentioned earlier, the same system is used for validating both config files and CLI arguments. Totally not judging, but Appium uses argparse for its CLI argument parsing. This package, and others like it, provides an API to define the arguments a command-line Node.js script accepts, and will ultimately return an object representation of the user-supplied arguments. Just as the schema defines what's allowed in a config file, it also defines what's allowed on the command-line.","title":"Validating CLI Arguments"},{"location":"contributing/config-system/#defining-cli-arguments-via-schema","text":"CLI arguments must be defined before their values can be validated. A JSON schema isn't a natural fit for defining CLI args--it needs some grease to make it work--but it's close enough that we can do so with an adapter and some custom metadata. In lib/cli/parser.js , there's a wrapper around argparse 's ArgumentParser ; it's called (wait for it)... ArgParser . The wrapper exists because we're doing some custom things with argparse , but is has nothing to do with the schema directly. An ArgParser instance is created and its parseArgs() method is called with the raw CLI arguments. The definition of the accepted arguments comes from lib/cli/args.js in part--here, all of the arguments not intended for use with the server subcommand are hard-coded (e.g., the driver subcommand and its subcommands). args.js also contains a function getServerArgs() , which in turn calls into toParserArgs in lib/schema/cli-args.js . lib/schema/cli-args.js can be considered the \"adapter\" layer between argparse and the schema. toParserArgs uses the flattenSchema function exported by lib/schema/schema.js , which \"squashes\" the schema into a key/value representation. Then, toParserArgs iterates over each key/value pair and \"converts\" it into a suitable ArgumentOption object for final handoff to ArgParser . This adapter ( cli-args.js ) is where most of the mess is hidden; let's explore this rat's nest a bit further.","title":"Defining CLI Arguments via Schema"},{"location":"contributing/config-system/#cli-schema-incongruities","text":"The conversion algorithm (see function subSchemaToArgDef in lib/schema/cli-args.js ) is mostly just hacks and special cases neatly packed into a function. Things that don't cleanly map from argparse to a JSON schema include, but are not limited to: A schema cannot natively express \"store the value of --foo=<value> in a property called bar \" in a schema (this corresponds to the ArgumentOption['dest'] prop). A schema cannot natively express aliases; e.g., --verbose can also be -v A schema enum is not restricted to multiple types, but argparse 's equivalent ArgumentOption['choices'] prop is A schema does not know about argparse 's concept of \"actions\" (note that Appium is not currently using custom actions--though it did, and it could again). argparse has no native type for email , hostname , ipv4 , uri etc., and the schema does Schema validation only validates , it does not perform translation, transformation, or coercion (mostly). argparse allows this. Schemas allow the null type, for whatever reason. Ever pass null on the CLI? argparse does not understand anything other than primitives; no objects, arrays, etc., and certainly not arrays of a particular type. All of the above cases and others are handled by the adapter. Warning Some decisions made in the adapter were arrived at via coin toss. If you are curious about why something is the way it is, it's likely that it had to do something . Let's look more closely at handling types.","title":"CLI &amp; Schema Incongruities"},{"location":"contributing/config-system/#argument-types-via-ajv","text":"While argparse allows consumers, via its API, to define the type of various arguments (e.g., a string, number, boolean flag, etc.), Appium mostly avoids these built-in types. Why is that? Well: We already know the type of an argument, because we've defined it in a schema. ajv provides validation against a schema. A schema allows for greater expression of types, allowed values, etc., than argparse can provide natively. The expressiveness of a schema allows for better error messaging. To that end, the adapter eschews argparse 's built-in types (see allowed string values of ArgumentOption['type'] ) and instead abuses the ability to provide a function as a type . The exception is boolean flags, which do not have a type , but rather action: 'store_true' . The world may never know why.","title":"Argument Types via ajv"},{"location":"contributing/config-system/#types-as-functions","text":"When a type is a function, the function performs both validation and coercion (if necessary). So what are these functions? Note: type is omitted (and thus not a function) from the ArgumentOption if the property type is boolean , and is instead provided an action property of store_true . Yes, this is weird. No, I don't know why. Well... it depends upon the schema. But generally speaking, we create a pipeline of functions, each corresponding to a keyword in the schema. Let's take the example of the port argument. In lieu of asking the OS which ports the appium -running user can bind to, this argument is expected to be an integer between 1 and 65535. This turns out to be two functions which we combine into a pipeline: Convert the value to an integer, if possible. Because every value in process.argv is a string , we must coerce if we want a number. Use ajv to validate the integer against the schema for port . A schema lets us define a range via the minimum and maximum keywords. Read more about how this works in Much like the config file validation, if errors are detected, Appium nicely tells the end-user and the process exits w/ some help text. For other arguments which are naturally of non-primitive types, things are not so straightforward.","title":"Types as Functions"},{"location":"contributing/config-system/#transformers","text":"Remember how argparse doesn't understand arrays? What if the most ergonomic way to express a value is, in fact, an array? Well, Appium can't accept an array on the CLI, even though it can accept one in the config file. But Appium can accept a comma-delimited string (a CSV \"line\"). Or a string filepath referring to a file which contains a delimited list. Either way: by the time the value gets out of the argument parser, it should be an array. And as mentioned above, the native facilities of a JSON schema cannot express this. However, it's possible to define a custom keyword which Appium can then detect and handle accordingly. So that's what Appium does. In this case, a custom keyword appiumCliTransformer is registered with ajv . The value of appiumCliTransformer (at the time of this writing) can be csv or json . In the base schema file, appium-config-schema.js , Appium uses appiumCliTransformer: 'csv' if this behavior is desired. Note Any property defined in the schema having type array will automatically uses the csv transformer. Likewise, a property having type object will use the json transformer. It's conceivable that array may want to use the json transformer, but otherwise, the presence of the appiumCliTransformer keyword on an array -or- object -typed property is not stricly necessary. The adapter (remember the adapter?) creates a pipeline function including a special \"CSV transformer\" (transformers are defined in lib/schema/cli-transformers.js ), and uses this function as the type property of the ArgumentOption passed into argparse . In this case, the type: 'array' in the schema is ignored. Note The config file doesn't need to perform any complex transformation of values, because it naturally allows Appium to define exactly what it expects. So Appium does no post-processing of config file values. Properties that do not need this special treatment use ajv directly for validation. How this works requires some explanation, so that's next.","title":"Transformers"},{"location":"contributing/config-system/#validation-of-individual-arguments-via-ajv","text":"When we think of a JSON schema, we tend to think, \"I have this JSON file and I want to validate it against the schema\". That's valid, and in fact Appium does just that with config files! However, Appium does not do this when validating arguments. Note During implementation, I was tempted to mash all of the arguments together into a config-file-like data structure and then validate it all at once. I think that would have been possible , but since an object full of CLI arguments is a flat key/value structure and the schema is not, this seemed like trouble. Instead, Appium validates a value against a specific property within the schema. To do this, it maintains a mapping between a CLI argument definition and its corresponding property. The mapping itself is a Map with a unique identifier for the argument as the key, and an ArgSpec ( lib/schema/arg-spec.js ) object as the value. An ArgSpec object stores the following metadata: Property Name Description name Canonical name of the argument, corresponding to the property name in the schema. extType? driver or plugin , if appropriate extName? Extension name, if appropriate ref Computed $id of the property in the schema arg Argument as accepted on CLI, without leading dashes dest Property name in parsed arguments object (as returned by argparse 's parse_args() ) defaultValue? Value of the default keyword in schema, if appropriate When a schema is finalized , the Map is populated with ArgSpec objects for all known arguments. So when the adapter is creating the pipeline of functions for the argument's type , it already has an ArgSpec for the argument. It creates a function which calls validate(value, ref) (in lib/schema/schema.js ) where value is whatever the user provided, and ref is the ref property of the ArgSpec . The concept is that ajv can validate using any ref it knows about; each property in a schema can be referenced by this ref whether it's defined or not. To help visualize, if a schema is: { \"$id\" : \"my-schema.json\" , \"type\" : \"object\" , \"properties\" : { \"foo\" : { \"type\" : \"number\" } } } The ref of foo would be my-schema.json#/properties/foo . Assuming our Ajv instance knows about this my-schema.json , then we can call its getSchema(ref) method (which has a schema property, but is a misnomer nonetheless) to get a validation function; validate(value, ref) in schema.js calls this validation function. Note The schema spec says a schema author can supply an explicit $id keyword to override this; it's unsupported by Appium at this time. If needed, extension authors must carefully use $ref without custom $id s. It's highly unlikely an extension would have a schema so complicated as to need this, however; Appium itself doesn't even use $ref to define its own properties! Next, let's take a look at how Appium loads schemas. This actually happens before any argument validation.","title":"Validation of Individual Arguments via ajv"},{"location":"contributing/config-system/#schema-loading","text":"Let's ignore extensions for a moment, and start with the base schema. When something first imports the lib/schema/schema.js module, an instance of an AppiumSchema is created. This is a singleton, and its methods are exported from the module (all of which are bound to the instance). The constructor does very little; it instantiates an Ajv instance and configures it with Appium's custom keywords and adds support for the format keyword via the ajv-formats module. Otherwise, the AppiumSchema instance does not interact with the Ajv instance until its finalize() method (exported as finalizeSchema() ) is called. When this method is called, we're saying \"we are not going to add any more schemas; go ahead and create ArgSpec objects and register schemas with ajv \". When does finalization happen? Well: When the appium executable begins, it checks for and configures extensions (hand-wave) in APPIUM_HOME . Only then does it start to think about arguments--it instantiates an ArgParser , which (as you'll recall) runs the adapter to convert the schema to arguments. Finalization happens here --when creating the parser. Appium need the schema(s) to be registered with ajv in order to create validation functions for arguments. Thereafter, Appium parses the arguments with the ArgParser . Finally, decides what to do with the returned object. Without extensions, finalize() still knows about the Appium base schema ( appium-config-schema.js ), and just registers that. However, step 1. above is doing a lot of work , so let's look at how extensions come into play.","title":"Schema Loading"},{"location":"contributing/config-system/#extension-support","text":"One of the design goals of this system is the following: An extension should be able to register custom CLI arguments with the Appium, and a user should be able to use them like any other argument . Previously, Appium 2.0 accepted arguments in this manner (via --driverArgs ), but validation was hand-rolled and required extension implementors to use a custom API. It also required the user to awkwardly pass a JSON string as the configuration on the command-line. Further, no contextual help (via --help ) existed for these arguments. Now, by providing a schema for its options, a driver or plugin can register CLI arguments and config file schemas with Appium. To register a schema, an extension must provide the appium.schema property in its package.json . The value may be a schema or a path to a schema. If the latter, the schema should be JSON or a CommonJS module (ESM not supported at this time, nor is YAML). For any property in this schema, the property will appear as a CLI argument of the form --<extension-type>-<extension-name>-<property-name> . For example, if the fake driver provides a property foo , the argument will be --driver-fake-foo , and will show in appium server --help like any other CLI argument. The corresponding property in a config file would be server.<extension-type>.<extension-name>.<property-name> , e.g.: { \"server\" : { \"driver\" : { \"fake\" : { \"foo\" : \"bar\" } } } } The naming convention described above avoids problems of one extension type having a name conflict with a different extension type. Note While an extension can provide aliases via appiumCliAliases , \"short\" flags are disallowed, since all arguments from extensions are prefixed with --<extension-type>-<extension-name>- . The extension name and argument name will be kebab-cased for the CLI, according to Lodash's rules around kebab-casing. The schema object will look much like Appium's base schema, but it will only have top-level properties (nested properties are currently unsupported). Example: { \"title\" : \"my rad schema for the cowabunga driver\" , \"type\" : \"object\" , \"properties\" : { \"fizz\" : { \"type\" : \"string\" , \"default\" : \"buzz\" , \"$comment\" : \"corresponds to CLI --driver-cowabunga-fizz\" } } } As written in a user's config file, this would be the server.driver.cowabunga.fizz property. When extensions are loaded, the schema property is verified and the schema is registered with the AppiumSchema (it is not registered with Ajv until finalize() is called). During finalization, each registered schema is added to the Ajv instance. The schema is assigned an $id based on the extension type and name (which overrides whatever the extension provides, if anything). Schemas are also forced to disallowed unknown arguments via the additionalProperties: false keyword. Behind the scenes, the base schema has driver and plugin properties which are objects. When finalized, a property is added to each--corresponding to an extension name--and the value of this property is a reference to the $id of a property in the extension schema. For example, the server.driver property will look like this: { \"driver\" : { \"cowabunga\" : { \"$ref\" : \"driver-cowabunga.json\" } } } This is why we call it the \"base\" schema--it is mutated when extensions provide schemas. The extension schemas are kept separately, but the references are added to the schema before it's ultimately added to ajv . This works because an Ajv instance understands references from any schema it knows about to any schema it knows about. Note This makes it impossible to provide a complete static schema for Appium and the installed extensions (as of Nov 5 2021). A static .json schema is generated from the base (via a Gulp task), but it does not contain any extension schemas. The static schema also has uses beyond Appium; e.g., IDEs can provide contextual error-checking of config files this way. Let's solve this? Just like how we look up the reference ID of a particular argument in the base schema, validation of arguments from extensions happens the exact same way. If the cowabunga driver has the schema ID driver-cowabunga.json , then the fizz property can be referenced from any schema registered with ajv via driver-cowabunga.json#/properties/fizz . \"Base\" schema arguments begin with appium.json#properties/ instead.","title":"Extension Support"},{"location":"contributing/config-system/#development-environment-support","text":"During the flow of development, a couple extra tasks have been automated to maintain the base schema: As a post-transpilation step, a lib/appium-config.schema.json gets generated from lib/schema/appium-config-schema.js (in addition to its CJS counterpart generated by Babel). This file is under version control. It ends up being copied to build/lib/appium-config.schema.json in this step. A pre-commit hook (see scripts/generate-schema-declarations.js in the root monorepo) generates a types/appium-config-schema.d.ts from the above JSON file. The types in types/types.d.ts depend upon this file. This file is under version control.","title":"Development Environment Support"},{"location":"contributing/config-system/#custom-keyword-reference","text":"Keywords are defined in lib/schema/keywords.js . appiumCliAliases : allows a schema to express aliases (e.g., a CLI argument can be --verbose or -v ). This is an array of strings. Strings shorter than three (3) characters will begin with a single dash ( - ) instead of a double-dash ( -- ). Note that any argument provided by an extension will begin with a double-dash, because these are required to have the --<extension-type>-<extension-name>- prefix. appiumCliDest : allows a schema to specify a custom property name in the post- argprase arguments objects. If not set, this becomes a camelCased string. appiumCliDescription : allows a schema to override the description of the argument when displayed on the command-line. This is useful paired with appiumCliTransformer (or array / object -typed properties), since there's a substantial difference between what a CLI-using user can provide vs. what a config-file-using user can provide. appiumCliTransformer : currently a choice between csv and json . These are custom functions which post-process a value. They are not used when loading & validating config files, but the idea should be that they result in the same object you'd get if you used whatever the config file wanted (e.g., an array of strings). csv is for comma-delimited strings and CSV files; json is for raw JSON strings and .json files. appiumCliIgnore : If true , do not support this property on the CLI. appiumDeprecated : If true , the property is considered \"deprecated\", and will be displayed as such to the user (e.g., in the --help output). Note the JSON Schema draft-2019-09 introduces a new keyword deprecated which we should use instead if upgrading to this metaschema. When doing so, appiumDeprecated should itself be marked as deprecated .","title":"Custom Keyword Reference"},{"location":"ecosystem/","text":"Appium has an ecosystem of related software and tools. In this guide we'll discuss important officially-supported and community-supported projects. Appium Inspector Appium has a graphical client which can be used to manually perform Appium commands, inspect app hierarchies, view screenshots, and more. It's very useful for Appium test development. You can learn more about the inspector here: Appium Inspector Drivers You can't use Appium without at least one driver! Here are the drivers that are officially recognized by Appium. Click on the link for each driver to see the specific installation instructions and documentation for that driver. To learn more about what drivers are and how they work, check out the Driver Intro Driver Installation Key Platform(s) Mode(s) Support XCUITest xcuitest iOS Native, Hybrid, Web Appium Team UiAutomator2 uiautomator2 Android Native, Hybrid, Web Appium Team Espresso espresso Android Native Appium Team Mac2 mac2 macOS Native Appium Team Safari safari macOS, iOS Web Appium Team Gecko safari macOS, Windows, Linux, Android Web Appium Team Windows windows Windows Native Community / Microsoft Flutter flutter iOS, Android Native Community Tizen tizen Android Native Community / Samsung Youi youiengine iOS, Android, macOS, Linux, tvOS Native Community / You.i And of course, you can install any other drivers you find out there by using the Appium driver CLI. Clients You need a clients to write and run Appium scripts. To learn more about clients, read our Client Intro . Here is the list of known Appium clients. You'll want to become very familiar with your client documentation (as well as the documentation of any Selenium client that the Appium client depends on) since that is what you will use as your primary interface to Appium. Client Language Support Appium Java client Java Appium Team Appium Python client Python Appium Team Appium Ruby client Ruby Appium Team WebDriverIO Node.js Community Appium .NET client C# Appium Team* RobotFramework DSL Community Warning Currently, the .NET client has a low level of maintenance/support. Expect bugs and incompatibility. We're looking for help here, so please reach out if you know .NET! In general, any W3C WebDriver spec-compatible client will also integrate well with Appium, though some Appium-specific commands may not be implemented in other clients.","title":"The Appium Ecosystem"},{"location":"ecosystem/#appium-inspector","text":"Appium has a graphical client which can be used to manually perform Appium commands, inspect app hierarchies, view screenshots, and more. It's very useful for Appium test development. You can learn more about the inspector here: Appium Inspector","title":"Appium Inspector"},{"location":"ecosystem/#drivers","text":"You can't use Appium without at least one driver! Here are the drivers that are officially recognized by Appium. Click on the link for each driver to see the specific installation instructions and documentation for that driver. To learn more about what drivers are and how they work, check out the Driver Intro Driver Installation Key Platform(s) Mode(s) Support XCUITest xcuitest iOS Native, Hybrid, Web Appium Team UiAutomator2 uiautomator2 Android Native, Hybrid, Web Appium Team Espresso espresso Android Native Appium Team Mac2 mac2 macOS Native Appium Team Safari safari macOS, iOS Web Appium Team Gecko safari macOS, Windows, Linux, Android Web Appium Team Windows windows Windows Native Community / Microsoft Flutter flutter iOS, Android Native Community Tizen tizen Android Native Community / Samsung Youi youiengine iOS, Android, macOS, Linux, tvOS Native Community / You.i And of course, you can install any other drivers you find out there by using the Appium driver CLI.","title":"Drivers"},{"location":"ecosystem/#clients","text":"You need a clients to write and run Appium scripts. To learn more about clients, read our Client Intro . Here is the list of known Appium clients. You'll want to become very familiar with your client documentation (as well as the documentation of any Selenium client that the Appium client depends on) since that is what you will use as your primary interface to Appium. Client Language Support Appium Java client Java Appium Team Appium Python client Python Appium Team Appium Ruby client Ruby Appium Team WebDriverIO Node.js Community Appium .NET client C# Appium Team* RobotFramework DSL Community Warning Currently, the .NET client has a low level of maintenance/support. Expect bugs and incompatibility. We're looking for help here, so please reach out if you know .NET! In general, any W3C WebDriver spec-compatible client will also integrate well with Appium, though some Appium-specific commands may not be implemented in other clients.","title":"Clients"},{"location":"ecosystem/build-docs/","text":"TODO","title":"Building Docs for Appium Extensions"},{"location":"ecosystem/build-drivers/","text":"Appium wants to make it easy for anyone to develop their own automation drivers as part of the Appium ecosystem. This guide will explain what's involved and how you can accomplish various driver development tasks using the tools Appium provides. This guide assumes you (1) are a competent user of Appium, (2) are a competent Node.js developer, and (3) that you have read and understood the Driver Intro . If that describes you, great! This guide will get you started. Before you create your driver Before you get to work implementing your driver, it's important to have a few things sorted out. For example, you need to know what your driver will do. Which platform is it trying to expose WebDriver automation for? Appium doesn't magically give you the power to automate any platform. All it does is give you a set of convenient tools for implementing the WebDriver Protocol. So if you want to create, for example, a driver for a new app platform, you'll need to know how to automate apps on that platform without Appium . This usually means that you need to be very familiar with app development for a given platform. And it usually means that you will rely on tools or SDKs provided by the platform vendor. Basically, if you can't answer the question \"how would I launch, remotely trigger behaviours, and read state from an app on this platform?\" then you're not quite ready to write an Appium driver . Make sure you do the research to feel comfortable that there is a path forward. Once there is, coding it up and making it available as an Appium driver should be the easy part! Other drivers to reference One of the greatest things about building an Appium driver is that there are already a number of open source Appium drivers which you can look at for reference. There is a fake-driver sample driver which does basically nothing other than showcase some of the things described in this guide. And of course, all of Appium's official drivers are open source and available in repositories at the project's GitHub organization. So if you ever find yourself asking, \"how does a driver do X?\", read the code for these drivers! Also don't be afraid to ask questions of the Appium developers if you get stuck; we're always happy to help make sure the driver development experience is a good one! Basic requirements for Appium drivers These are the things your driver must do (or be), if you want it to be a valid Appium driver. Node.js package with Appium extension metadata All Appium drivers are fundamentally Node.js packages, and therefore must have a valid package.json . Your driver is not limited to Node.js, but it must provide an adapter written in Node.js so it can be loaded by Appium. Your package.json must include appium as a peerDependency . The requirements for the dependency versions should be as loose as possible (unless you happen to know your driver will only work with certain versions of Appium). For Appium 2.0, for example, this would look something like ^2.0.0 , declaring that your driver works with any version of Appium that starts with 2.x. Your package.json must contain an appium field, like this (we call this the 'Appium extension metadata'): ```json { ..., \"appium\": { \"driverName\": \"fake\", \"automationName\": \"Fake\", \"platformNames\": [ \"Fake\" ], \"mainClass\": \"FakeDriver\" }, ... } ``` The required subfields are: driverName : this should be a short name for your driver. automationName : this should be the string users will use for their appium:automationName capability to tell Appium to use your driver. platformNames : this is an array of one or more platform names considered valid for your driver. When a user sends in the platformName capability to start a session, it must be included in this list for your driver to handle the session. Known platform name strings include: iOS , tvOS , macOS , Windows , Android . mainClass : this is a named export (in CommonJS style) from your main field. It must be a class which extends Appium's BaseDriver (see below). Extend Appium's BaseDriver class Ultimately, your driver is much easier to write because most of the hard work of implementing the WebDriver protocol and handling certain common logic is taken care of already by Appium. This is all encoded up as a class which Appium exports for you to use, called BaseDriver . It is exported from appium/driver , so you can use one of these styles to import it and create your own class that extends it: import { BaseDriver } from 'appium/driver' ; // or: const {BaseDriver} = require('appium/driver'); export class MyDriver extends BaseDriver { } Make your driver available That's basically it! With a Node.js package exporting a driver class and with correct Appium extension metadata, you've got yourself an Appium driver! Now it doesn't do anything, but you can load it up in Appium, start and stop sessions with it, etc... To make it available to users, you could publish it via NPM. When you do so, your driver will be installable via the Appium CLI: appium driver install --source=npm <driver-package-on-npm> It's a good idea to test your driver first, of course. One way to see how it works within Appium is to install it locally first: appium driver install --source=local /path/to/your/driver Developing your driver How you develop your driver is up to you. It is convenient, however, to run it from within Appium without having to do lots of publishing and installing. The most straightforward way to do this is to include the most recent version of Appium as a devDependency , and then also your own driver, like this: { \"devDependencies\" : { ... , \"appium\" : \"^2.0.0\" , \"your-driver\" : \"file:.\" , ... } } Now, you can run Appium locally ( npm exec appium or npx appium ), and because your driver is listed as a dependency alongside it, it will be automatically \"installed\" and available. You can design your e2e tests this way, or if you're writing them in Node.js, you can simply import Appium's start server methods to handle starting and stopping the Appium server in Node. (TODO: reference an implementation of this in one of the open source drivers when ready). Another way to do local development with an existing Appium server install is to simply install your driver locally: appium driver install --source=local /path/to/your/driver/dev/dir Standard driver implementation ideas These are things you will probably find yourself wanting to do when creating a driver. Set up state in a constructor If you define your own constructor, you'll need to call super to make sure all the standard state is set up correctly: constructor ( args ) { super ( args ); // now do your own thing } The args parameter here is the object containing all the CLI args used to start the Appium server. Define and validate accepted capabilities You can define your own capabilities and basic validation for them. Users will always be able to send in capabilities that you don't define, but if they send in capabilities you have explicitly defined, then Appium will validate that they are of the correct type (and will check for the presence of required capabilities). If you want to turn capability validation off entirely, set this.shouldValidateCaps to false in your constructor. To give Appium your validation constraints, set this.desiredCapConstraints to a validation object in your constructor. Validation objects can be somewhat complex. Here's an example from the UiAutomator2 driver: { app : { presence : true , isString : true }, automationName : { isString : true }, browserName : { isString : true }, launchTimeout : { isNumber : true }, } Start a session and read capabilities Appium's BaseDriver already implements the createSession command, so you don't have to. However it's very common to need to perform your own startup actions (launching an app, running some platform code, or doing different things based on capabilities you have defined for your driver). So you'll probably end up overriding createSession . You can do so by defining the method in your driver: async createSession ( jwpCaps , reqCaps , w3cCaps , otherDriverData ) { const [ sessionId , caps ] = super . createSession ( w3cCaps ); // do your own stuff here return [ sessionId , caps ]; } For legacy reasons, your function will receive old-style JSON Wire Protocol desired and required caps as the first two arguments. Given that the old protocol isn't supported anymore and clients have all been updated, you can instead only rely on the w3cCaps parameter. (For a discussion about what otherDriverData is about, see the section below on concurrent drivers). You'll want to make sure to call super.createSession in order to get the session ID as well as the processed capabilities (note that capabilities are also set on this.caps ; modifying caps locally here would have no effect other than changing what the user sees in the create session response). So that's it! You can fill out the middle section with whatever startup logic your driver requires. End a session If your driver requires any cleanup or shutdown logic, it's best to do it as part of overriding the implementation of deleteSession : async deleteSession () { // do your own cleanup here // don't forget to call super! await super . deleteSession (); } It's very important not to throw any errors here if possible so that all parts of session cleanup can succeed! Access capabilities and CLI args You'll often want to read parameters the user has set for the session, whether as CLI args or as capabilities. The easiest way to do this is to access this.opts , which is a merge of all options, from the CLI or from capabilities. So for example to access the appium:app capability, you could simply get the value of this.opts.app . If you care about knowing whether something was sent in as a CLI arg or a capability, you can access the this.cliArgs and this.caps objects explicitly. In all cases, the appium: capability prefix will have been stripped away by the time you are accessing values here, for convenience. Implement WebDriver commands You handle WebDriver commands by implementing functions in your driver class. Each member of the WebDriver Protocol, plus the various Appium extensions, has a corresponding function that you implement if you want to support that command in your driver. The best way to see which commands Appium supports and which method you need to implement for each command is to look at Appium's routes.js . Each route object in this file tells you the command name as well as the parameters you'd expect to receive for that command. Let's take this block for example: '/session/:sessionId/url' : { GET : { command : 'getUrl' }, POST : { command : 'setUrl' , payloadParams : { required : [ 'url' ]}}, } Here we see that the route /session/:sessionId/url is mapped to two commands, one for a GET request and one for a POST request. If we want to allow our driver to change the \"url\" (or whatever that might mean for our driver), we can therefore implement the setUrl command, knowing it will take the url parameter: async setUrl ( url ) { // your implementation here } A few notes: - all command methods should be async functions or otherwise return a Promise - you don't need to worry about protocol encoding/decoding. You will get JS objects as params, and can return JSON-serializable objects in response. Appium will take care of wrapping it up in the WebDriver protocol response format, turning it into JSON, etc... - all session-based commands receive the sessionId parameter as the last parameter - all element-based commands receive the elementId parameter as the second-to-last parameter - if your driver doesn't implement a command, users can still try to access the command, and will get a 501 Not Yet Implemented response error. Implement element finding Element finding is a special command implementation case. You don't actually want to override findElement or findElements , even though those are what are listed in routes.js . Appium does a lot of work for you if instead you implement this function: async findElOrEls ( strategy , selector , mult , context ) { // find your element here } Here's what gets passed in: strategy - a string, the locator strategy being used selector - a string, the selector mult - boolean, whether the user has requested one element or all elements matching the selector context - (optional) if defined, will be a W3C Element (i.e., a JS object with the W3C element identifier as the key and the element ID as the value) And you need to return one of the following: a single W3C element (an object as described above) an array of W3C elements Note that you can import that W3C web element identifier from appium/support : import { util } from 'appium/support' ; const { W3C_WEB_ELEMENT_IDENTIFIER } = util ; What you do with elements is up to you! Usually you end up keeping a cache map of IDs to actual element \"objects\" or whatever the equivalent is for your platform. Define valid locator strategies Your driver might only support a subset of the standard WebDriver locator strategies, or it might add its own custom locator strategies. To tell Appium which strategies are considered valid for your driver, create an array of strategies and assign it to this.locatorStrategies : this . locatorStrategies = [ 'xpath' , 'custom-strategy' ]; Appium will throw an error if the user attempts to use any strategies other than the allowed ones, which enables you to keep your element finding code clean and deal with only the strategies you know about. By default, the list of valid strategies is empty, so if your driver isn't simply proxying to another WebDriver endpoint, you'll need to define some. The protocol-standard locator strategies are defined here . Throw WebDriver-specific errors The WebDriver spec defines a set of error codes to accompany command responses if an error occurred. Appium has created error classes for each of these codes, so you can throw the appropriate error from inside a command, and it will do the right thing in terms of the protocol response to the user. To get access to these error classes, import them from appium/driver : import {errors} from 'appium/driver'; throw new errors.NoSuchElementError(); Log messages to the Appium log You can always use console.log , of course, but Appium provides a nice logger for you as this.log (it has .info , .debug , .log , .warn , .error methods on it for differing log levels). If you want to create an Appium logger outside of a driver context (say in a script or helper file), you can always construct your own too: import { logging } from 'appium/support' ; const log = logging . getLogger ( 'MyDriver' ); Further possibilities for Appium drivers These are things your driver can do to take advantage of extra driver features or do its job more conveniently. Add a schema for custom command line arguments You can add custom CLI args if you want your driver to receive data from the command line when the Appium server is started (for example, ports that a server administrator should set that should not be passed in as capabilities. To define CLI arguments (or configuration properties) for the Appium server, your extension must provide a schema . In the appium property of your extension's package.json , add a schema property. This will either a) be a schema itself, or b) be a path to a schema file. The rules for these schemas: Schemas must conform to JSON Schema Draft-07 . If the schema property is a path to a schema file, the file must be in JSON or JS (CommonJS) format. Custom $id values are unsupported. To use $ref , provide a value relative to the schema root, e.g., /properties/foo . Known values of the format keyword are likely supported, but various other keywords may be unsupported. If you find a keyword that is unsupported which you need to use, please ask for support or send a PR! The schema must be of type object ( {\"type\": \"object\"} ), containing the arguments in a properties keyword. Nested properties are unsupported. Example: { \"type\" : \"object\" , \"properties\" : { \"test-web-server-port\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"The port to use for the test web server\" }, \"test-web-server-host\" : { \"type\" : \"string\" , \"description\" : \"The host to use for the test web server\" , \"default\" : \"sillyhost\" } } } The above schema defines two properties which can be set via CLI argument or configuration file. If this extension is a driver and its name is \"horace\", the CLI args would be --driver-horace-test-web-server-port and --driver-horace-test-web-server-host , respectively. Alternatively, a user could provide a configuration file containing: { \"server\" : { \"driver\" : { \"horace\" : { \"test-web-server-port\" : 1234 , \"test-web-server-host\" : \"localhorse\" } } } } Add driver scripts Sometimes you might want users of your driver to be able to run scripts outside the context of a session (for example, to run a script that pre-builds aspects of your driver). To support this, you can add a map of script names and JS files to the scripts field within your Appium extension metadata. So let's say you've created a script in your project that lives in a scripts directory in your project, named driver-prebuild.js . Then you could add a scripts field like this: { \"scripts\" : { \"prebuild\" : \"./scripts/driver-prebuild.js\" } } Now, assuming your driver is named mydriver , users of your driver can run appium driver run mydriver prebuild , and your script will execute. Proxy commands to another WebDriver implementation A very common design architecture for Appium drivers is to have some kind of platform-specific WebDriver implementation that the Appium driver interfaces with. For example, the Appium UiAutomator2 driver interfaces with a special (Java-based) server running on the Android device. In webview mode, it also interfaces with Chromedriver. If you find yourself in this situation, it is extremely easy to tell Appium that your driver is just going to be proxying WebDriver commands straight to another endpoint. First, let Appium know that your driver can proxy by implementing the canProxy method: canProxy () { return true ; } Next, tell Appium which WebDriver routes it should not attempt to proxy (there often end up being certain routes that you don't want to forward on): getProxyAvoidList () { return [ [ 'POST' , new RegExp ( '^/session/[^/]+/appium' )] ]; } The proxy avoidance list should be an array of arrays, where each inner array has an HTTP method as its first member, and a regular expression as its second. If the regular expression matches the route, then the route will not be proxied and instead will be handled by your driver. In this example, we are avoiding proxying all POST routes that have the appium prefix. Next, we have to set up the proxying itself. The way to do this is to use a special class from Appium called JWProxy . (The name means \"JSON Wire Proxy\" and is related to a legacy implementation of the protocol). You'll want to create a JWProxy object using the details required to connect to the remote server: // import {JWProxy} from 'appium/driver'; const proxy = new JWProxy ({ server : 'remote.server' , port : 1234 , base : '/' , }); this . proxyReqRes = proxy . proxyReqRes . bind ( proxy ); this . proxyCommand = proxy . command . bind ( proxy ); Here we are creating a proxy object and assigning some of its methods to this under the names proxyReqRes and proxyCommand . This is required for Appium to use the proxy, so don't forget this step! The JWProxy has a variety of other options which you can check out in the source code, as well. (TODO: publish options as API docs and link here). Finally, we need a way to tell Appium when the proxy is active. For your driver it might always be active, or it might only be active when in a certain context. You can define the logic as an implementation of proxyActive : proxyActive () { return true ; // or use custom logic } With those pieces in play, you won't have to reimplement anything that's already implemented by the remote endpoint you're proxying to. Appium will take care of all the proxying for you. Extend the existing protocol with new commands You may find that the existing commands don't cut it for your driver. If you want to expose behaviours that don't map to any of the existing commands, you can create new commands in one of two ways: Extending the WebDriver protocol and creating client-side plugins to access the extensions Overloading the Execute Script command by defining \"Execute Methods\" If you want to follow the first path, you can direct Appium to recognize new methods and add them to its set of allowed HTTP routes and command names. You do this by assigning the newMethodMap static variable in your driver class to an object of the same form as Appium's routes.js object. For example, here is the newMethodMap for the FakeDriver example driver: static newMethodMap = { '/session/:sessionId/fakedriver' : { GET : { command : 'getFakeThing' }, POST : { command : 'setFakeThing' , payloadParams : { required : [ 'thing' ]}}, }, '/session/:sessionId/fakedriverargs' : { GET : { command : 'getFakeDriverArgs' }, }, }; In this example we're adding a few new routes and a total of 3 new commands. For more examples of how to define commands in this way, it's best to have a look through routes.js . Now all you need to do is implement the command handlers in the same way you'd implement any other Appium command. The downside of this way of adding new commands is that people using the standard Appium clients won't have nice client-side functions designed to target these endpoints. So you would need to create and release client-side plugins for each language you want to support (directions or examples can be found at the relevant client docs). An alternative to this way of doing things is to overload a command which all WebDriver clients have access to already: Execute Script. Appium provides some a convenient tool for making this easy. Let's say you are building a driver for stereo system called soundz , and you wanted to create a command for playing a song by name. You could expose this to your users in such a way that they call something like: // webdriverio example. Calling webdriverio's `executeScript` command is what trigger's Appium's // Execute Script command handler driver . executeScript ( 'soundz: playSong' , [{ song : 'Stairway to Heaven' , artist : 'Led Zeppelin' }]); Then in your driver code you can define the static property executeMethodMap as a mapping of script names to methods on your driver. It has the same basic form as newMethodMap , described above. Once executeMethodMap is defined, you'll also need to implement the Execute Script command handler, which according to Appium's routes mapping is called execute . The implementation can call a single helper function, this.executeMethod , which takes care of looking at the script and arguments the user sent in and routing it to the correct custom handler you've defined. Here's an example: static executeMethodMap = { 'soundz: playSong' , { command : 'soundzPlaySong' , params : { required : [ 'song' , 'artist' ], optional : []}, } } async soundzPlaySong ( song , artist ) { // play the song based on song and artist details } async execute ( script , args ) { return await this . executeMethod ( script , args ); } A couple notes about this system: 1. The arguments array sent via the call to Execute Script must contain only zero or one element(s). The first item in the list is considered to be the parameters object for your method. These parameters will be parsed, validated, and then applied to your overload method in the order specified in executeMethodMap (the order specified in the required parameters list, followed by the optional parameters list). I.e., this framework assumes only a single actual argument sent in via Execute Script (and this argument should be an object with keys/values representing the parameters your execute method expects). 1. Appium does not automatically implement execute (the Execute Script handler) for you. You may wish, for example, to only call the executeMethod helper function when you're not in proxy mode! 1. The executeMethod helper will reject with an error if a script name doesn't match one of the script names defined as a command in executeMethodMap , or if there are missing parameters. Implement handling of Appium settings Appium users can send parameters to your driver via CLI args as well as via capabilities. But these cannot change during the course of a test, and sometimes users want to adjust parameters mid-test. Appium has a Settings API for this purpose. To support settings in your own driver, first of all define this.settings to be an instance of the appropriate class, in your constructor: // import {DeviceSettings} from 'appium/driver'; this . settings = new DeviceSettings (); Now, you can read user settings any time simply by calling this.settings.getSettings() . This will return a JS object where the settings names are keys and have their corresponding values. If you want to assign some default settings, or run some code on your end whenever settings are updated, you can do both of these things as well. constructor () { const defaults = { setting1 : 'value1' }; this . settings = new DeviceSettings ( defaults , this . onSettingsUpdate . bind ( this )); } async onSettingsUpdate ( key , value ) { // do anything you want here with key and value } Make itself aware of resources other concurrent drivers are using Let's say your driver uses up some system resources, like ports. There are a few ways to make sure that multiple simultaneous sessions don't use the same resources: Have your users specify resource IDs via capabilities ( appium:driverPort etc) Just always use free resources (find a new random port for each session) Have each driver express what resources it is using, then examine currently-used resources from other drivers when a new session begins. To support this third strategy, you can implement get driverData in your driver to return what sorts of resources your driver is currently using, for example: get driverData () { return { specialPort : 1234 , specialFile : /path/to/file} } Now, when a new session is started on your driver, the driverData response from any other simultaneously running drivers (of the same type) will also be included, as the last parameter of the createSession method: async createSession ( jwpCaps , reqCaps , w3cCaps , driverData ) You can dig into this driverData array to see what resources other drivers are using to help determine which ones you want to use for this particular session. Warning Be careful here, since driverData is only passed between sessions of a single running Appium server. There's nothing to stop a user from running multiple Appium servers and requesting your driver simultaneously on each of them. In this case, you won't be able to ensure independence of resources via driverData , so you might consider using file-based locking mechanisms or something similar. Warning It's also important to note you will only receive driverData for other instances of your driver. So unrelated drivers also running may still be using some system resources. In general Appium doesn't provide any features for ensuring unrelated drivers don't interfere with one another, so it's up to the drivers to allow users to specify resource locations or addresses to avoid clashes. Log events to the Appium event timeline Appium has an Event Timing API which allows users to get timestamps for certain server-side events (like commands, startup milestones, etc...) and display them on a timeline. The feature basically exists to allow introspection of timing for internal events to help with debugging or running analysis on Appium driver internals. You can add your own events to the event log: this . logEvent ( name ); Simply provide a name for the event and it will be added at the current time, and made accessible as part of the event log for users. Hide behaviour behind security flags Appium has a feature-flag based security model that allows driver authors to hide certain features behind security flags. What this means is that if you have a feature you deem insecure and want to require server admins to opt in to it, you can require that they enable the feature by adding it to the --allow-insecure list or turning off server security entirely. To support the check within your own driver, you can call this.isFeatureEnabled(featureName) to determine whether a feature of the given name has been enabled. Or, if you want to simply short-circuit and throw an error if the feature isn't enabled, you can call this.assertFeatureEnabled(featureName) . Use a temp dir for files If you want to use a temporary directory for files your driver creates that are not important to keep around between computer or server restarts, you can simply read from this.opts.tmpDir . This reads the temporary directory location from @appium/support , potentially overridden by a CLI flag. I.e., it's safer than writing to your own temporary directory because the location here plays nicely with possible user configuration. this.opts.tmpDir is a string, the path to the dir. Deal with unexpected shutdowns or crashes Your driver might run into a situation where it can't continue operating normally. For example, it might detect that some external service has crashed and nothing will work anymore. In this case, it can call this.startUnexpectedShutdown(err) with an error object including any details, and Appium will attempt to gracefully handle any remaining requests before shutting down the session. If you want to perform some of your own cleanup logic when you encounter this condition, you can either do so immediately before calling this.startUnexpectedShutdown , or you can attach a handler to the unexpected shutdown event and run your cleanup logic \"out of band\" so to speak: this . onUnexpectedShutdown ( handler ) handler should be a function which receives an error object (representing the reason for the unexpected shutdown).","title":"Building Appium Drivers"},{"location":"ecosystem/build-drivers/#before-you-create-your-driver","text":"Before you get to work implementing your driver, it's important to have a few things sorted out. For example, you need to know what your driver will do. Which platform is it trying to expose WebDriver automation for? Appium doesn't magically give you the power to automate any platform. All it does is give you a set of convenient tools for implementing the WebDriver Protocol. So if you want to create, for example, a driver for a new app platform, you'll need to know how to automate apps on that platform without Appium . This usually means that you need to be very familiar with app development for a given platform. And it usually means that you will rely on tools or SDKs provided by the platform vendor. Basically, if you can't answer the question \"how would I launch, remotely trigger behaviours, and read state from an app on this platform?\" then you're not quite ready to write an Appium driver . Make sure you do the research to feel comfortable that there is a path forward. Once there is, coding it up and making it available as an Appium driver should be the easy part!","title":"Before you create your driver"},{"location":"ecosystem/build-drivers/#other-drivers-to-reference","text":"One of the greatest things about building an Appium driver is that there are already a number of open source Appium drivers which you can look at for reference. There is a fake-driver sample driver which does basically nothing other than showcase some of the things described in this guide. And of course, all of Appium's official drivers are open source and available in repositories at the project's GitHub organization. So if you ever find yourself asking, \"how does a driver do X?\", read the code for these drivers! Also don't be afraid to ask questions of the Appium developers if you get stuck; we're always happy to help make sure the driver development experience is a good one!","title":"Other drivers to reference"},{"location":"ecosystem/build-drivers/#basic-requirements-for-appium-drivers","text":"These are the things your driver must do (or be), if you want it to be a valid Appium driver.","title":"Basic requirements for Appium drivers"},{"location":"ecosystem/build-drivers/#nodejs-package-with-appium-extension-metadata","text":"All Appium drivers are fundamentally Node.js packages, and therefore must have a valid package.json . Your driver is not limited to Node.js, but it must provide an adapter written in Node.js so it can be loaded by Appium. Your package.json must include appium as a peerDependency . The requirements for the dependency versions should be as loose as possible (unless you happen to know your driver will only work with certain versions of Appium). For Appium 2.0, for example, this would look something like ^2.0.0 , declaring that your driver works with any version of Appium that starts with 2.x. Your package.json must contain an appium field, like this (we call this the 'Appium extension metadata'): ```json { ..., \"appium\": { \"driverName\": \"fake\", \"automationName\": \"Fake\", \"platformNames\": [ \"Fake\" ], \"mainClass\": \"FakeDriver\" }, ... } ``` The required subfields are: driverName : this should be a short name for your driver. automationName : this should be the string users will use for their appium:automationName capability to tell Appium to use your driver. platformNames : this is an array of one or more platform names considered valid for your driver. When a user sends in the platformName capability to start a session, it must be included in this list for your driver to handle the session. Known platform name strings include: iOS , tvOS , macOS , Windows , Android . mainClass : this is a named export (in CommonJS style) from your main field. It must be a class which extends Appium's BaseDriver (see below).","title":"Node.js package with Appium extension metadata"},{"location":"ecosystem/build-drivers/#extend-appiums-basedriver-class","text":"Ultimately, your driver is much easier to write because most of the hard work of implementing the WebDriver protocol and handling certain common logic is taken care of already by Appium. This is all encoded up as a class which Appium exports for you to use, called BaseDriver . It is exported from appium/driver , so you can use one of these styles to import it and create your own class that extends it: import { BaseDriver } from 'appium/driver' ; // or: const {BaseDriver} = require('appium/driver'); export class MyDriver extends BaseDriver { }","title":"Extend Appium's BaseDriver class"},{"location":"ecosystem/build-drivers/#make-your-driver-available","text":"That's basically it! With a Node.js package exporting a driver class and with correct Appium extension metadata, you've got yourself an Appium driver! Now it doesn't do anything, but you can load it up in Appium, start and stop sessions with it, etc... To make it available to users, you could publish it via NPM. When you do so, your driver will be installable via the Appium CLI: appium driver install --source=npm <driver-package-on-npm> It's a good idea to test your driver first, of course. One way to see how it works within Appium is to install it locally first: appium driver install --source=local /path/to/your/driver","title":"Make your driver available"},{"location":"ecosystem/build-drivers/#developing-your-driver","text":"How you develop your driver is up to you. It is convenient, however, to run it from within Appium without having to do lots of publishing and installing. The most straightforward way to do this is to include the most recent version of Appium as a devDependency , and then also your own driver, like this: { \"devDependencies\" : { ... , \"appium\" : \"^2.0.0\" , \"your-driver\" : \"file:.\" , ... } } Now, you can run Appium locally ( npm exec appium or npx appium ), and because your driver is listed as a dependency alongside it, it will be automatically \"installed\" and available. You can design your e2e tests this way, or if you're writing them in Node.js, you can simply import Appium's start server methods to handle starting and stopping the Appium server in Node. (TODO: reference an implementation of this in one of the open source drivers when ready). Another way to do local development with an existing Appium server install is to simply install your driver locally: appium driver install --source=local /path/to/your/driver/dev/dir","title":"Developing your driver"},{"location":"ecosystem/build-drivers/#standard-driver-implementation-ideas","text":"These are things you will probably find yourself wanting to do when creating a driver.","title":"Standard driver implementation ideas"},{"location":"ecosystem/build-drivers/#set-up-state-in-a-constructor","text":"If you define your own constructor, you'll need to call super to make sure all the standard state is set up correctly: constructor ( args ) { super ( args ); // now do your own thing } The args parameter here is the object containing all the CLI args used to start the Appium server.","title":"Set up state in a constructor"},{"location":"ecosystem/build-drivers/#define-and-validate-accepted-capabilities","text":"You can define your own capabilities and basic validation for them. Users will always be able to send in capabilities that you don't define, but if they send in capabilities you have explicitly defined, then Appium will validate that they are of the correct type (and will check for the presence of required capabilities). If you want to turn capability validation off entirely, set this.shouldValidateCaps to false in your constructor. To give Appium your validation constraints, set this.desiredCapConstraints to a validation object in your constructor. Validation objects can be somewhat complex. Here's an example from the UiAutomator2 driver: { app : { presence : true , isString : true }, automationName : { isString : true }, browserName : { isString : true }, launchTimeout : { isNumber : true }, }","title":"Define and validate accepted capabilities"},{"location":"ecosystem/build-drivers/#start-a-session-and-read-capabilities","text":"Appium's BaseDriver already implements the createSession command, so you don't have to. However it's very common to need to perform your own startup actions (launching an app, running some platform code, or doing different things based on capabilities you have defined for your driver). So you'll probably end up overriding createSession . You can do so by defining the method in your driver: async createSession ( jwpCaps , reqCaps , w3cCaps , otherDriverData ) { const [ sessionId , caps ] = super . createSession ( w3cCaps ); // do your own stuff here return [ sessionId , caps ]; } For legacy reasons, your function will receive old-style JSON Wire Protocol desired and required caps as the first two arguments. Given that the old protocol isn't supported anymore and clients have all been updated, you can instead only rely on the w3cCaps parameter. (For a discussion about what otherDriverData is about, see the section below on concurrent drivers). You'll want to make sure to call super.createSession in order to get the session ID as well as the processed capabilities (note that capabilities are also set on this.caps ; modifying caps locally here would have no effect other than changing what the user sees in the create session response). So that's it! You can fill out the middle section with whatever startup logic your driver requires.","title":"Start a session and read capabilities"},{"location":"ecosystem/build-drivers/#end-a-session","text":"If your driver requires any cleanup or shutdown logic, it's best to do it as part of overriding the implementation of deleteSession : async deleteSession () { // do your own cleanup here // don't forget to call super! await super . deleteSession (); } It's very important not to throw any errors here if possible so that all parts of session cleanup can succeed!","title":"End a session"},{"location":"ecosystem/build-drivers/#access-capabilities-and-cli-args","text":"You'll often want to read parameters the user has set for the session, whether as CLI args or as capabilities. The easiest way to do this is to access this.opts , which is a merge of all options, from the CLI or from capabilities. So for example to access the appium:app capability, you could simply get the value of this.opts.app . If you care about knowing whether something was sent in as a CLI arg or a capability, you can access the this.cliArgs and this.caps objects explicitly. In all cases, the appium: capability prefix will have been stripped away by the time you are accessing values here, for convenience.","title":"Access capabilities and CLI args"},{"location":"ecosystem/build-drivers/#implement-webdriver-commands","text":"You handle WebDriver commands by implementing functions in your driver class. Each member of the WebDriver Protocol, plus the various Appium extensions, has a corresponding function that you implement if you want to support that command in your driver. The best way to see which commands Appium supports and which method you need to implement for each command is to look at Appium's routes.js . Each route object in this file tells you the command name as well as the parameters you'd expect to receive for that command. Let's take this block for example: '/session/:sessionId/url' : { GET : { command : 'getUrl' }, POST : { command : 'setUrl' , payloadParams : { required : [ 'url' ]}}, } Here we see that the route /session/:sessionId/url is mapped to two commands, one for a GET request and one for a POST request. If we want to allow our driver to change the \"url\" (or whatever that might mean for our driver), we can therefore implement the setUrl command, knowing it will take the url parameter: async setUrl ( url ) { // your implementation here } A few notes: - all command methods should be async functions or otherwise return a Promise - you don't need to worry about protocol encoding/decoding. You will get JS objects as params, and can return JSON-serializable objects in response. Appium will take care of wrapping it up in the WebDriver protocol response format, turning it into JSON, etc... - all session-based commands receive the sessionId parameter as the last parameter - all element-based commands receive the elementId parameter as the second-to-last parameter - if your driver doesn't implement a command, users can still try to access the command, and will get a 501 Not Yet Implemented response error.","title":"Implement WebDriver commands"},{"location":"ecosystem/build-drivers/#implement-element-finding","text":"Element finding is a special command implementation case. You don't actually want to override findElement or findElements , even though those are what are listed in routes.js . Appium does a lot of work for you if instead you implement this function: async findElOrEls ( strategy , selector , mult , context ) { // find your element here } Here's what gets passed in: strategy - a string, the locator strategy being used selector - a string, the selector mult - boolean, whether the user has requested one element or all elements matching the selector context - (optional) if defined, will be a W3C Element (i.e., a JS object with the W3C element identifier as the key and the element ID as the value) And you need to return one of the following: a single W3C element (an object as described above) an array of W3C elements Note that you can import that W3C web element identifier from appium/support : import { util } from 'appium/support' ; const { W3C_WEB_ELEMENT_IDENTIFIER } = util ; What you do with elements is up to you! Usually you end up keeping a cache map of IDs to actual element \"objects\" or whatever the equivalent is for your platform.","title":"Implement element finding"},{"location":"ecosystem/build-drivers/#define-valid-locator-strategies","text":"Your driver might only support a subset of the standard WebDriver locator strategies, or it might add its own custom locator strategies. To tell Appium which strategies are considered valid for your driver, create an array of strategies and assign it to this.locatorStrategies : this . locatorStrategies = [ 'xpath' , 'custom-strategy' ]; Appium will throw an error if the user attempts to use any strategies other than the allowed ones, which enables you to keep your element finding code clean and deal with only the strategies you know about. By default, the list of valid strategies is empty, so if your driver isn't simply proxying to another WebDriver endpoint, you'll need to define some. The protocol-standard locator strategies are defined here .","title":"Define valid locator strategies"},{"location":"ecosystem/build-drivers/#throw-webdriver-specific-errors","text":"The WebDriver spec defines a set of error codes to accompany command responses if an error occurred. Appium has created error classes for each of these codes, so you can throw the appropriate error from inside a command, and it will do the right thing in terms of the protocol response to the user. To get access to these error classes, import them from appium/driver : import {errors} from 'appium/driver'; throw new errors.NoSuchElementError();","title":"Throw WebDriver-specific errors"},{"location":"ecosystem/build-drivers/#log-messages-to-the-appium-log","text":"You can always use console.log , of course, but Appium provides a nice logger for you as this.log (it has .info , .debug , .log , .warn , .error methods on it for differing log levels). If you want to create an Appium logger outside of a driver context (say in a script or helper file), you can always construct your own too: import { logging } from 'appium/support' ; const log = logging . getLogger ( 'MyDriver' );","title":"Log messages to the Appium log"},{"location":"ecosystem/build-drivers/#further-possibilities-for-appium-drivers","text":"These are things your driver can do to take advantage of extra driver features or do its job more conveniently.","title":"Further possibilities for Appium drivers"},{"location":"ecosystem/build-drivers/#add-a-schema-for-custom-command-line-arguments","text":"You can add custom CLI args if you want your driver to receive data from the command line when the Appium server is started (for example, ports that a server administrator should set that should not be passed in as capabilities. To define CLI arguments (or configuration properties) for the Appium server, your extension must provide a schema . In the appium property of your extension's package.json , add a schema property. This will either a) be a schema itself, or b) be a path to a schema file. The rules for these schemas: Schemas must conform to JSON Schema Draft-07 . If the schema property is a path to a schema file, the file must be in JSON or JS (CommonJS) format. Custom $id values are unsupported. To use $ref , provide a value relative to the schema root, e.g., /properties/foo . Known values of the format keyword are likely supported, but various other keywords may be unsupported. If you find a keyword that is unsupported which you need to use, please ask for support or send a PR! The schema must be of type object ( {\"type\": \"object\"} ), containing the arguments in a properties keyword. Nested properties are unsupported. Example: { \"type\" : \"object\" , \"properties\" : { \"test-web-server-port\" : { \"type\" : \"integer\" , \"minimum\" : 1 , \"maximum\" : 65535 , \"description\" : \"The port to use for the test web server\" }, \"test-web-server-host\" : { \"type\" : \"string\" , \"description\" : \"The host to use for the test web server\" , \"default\" : \"sillyhost\" } } } The above schema defines two properties which can be set via CLI argument or configuration file. If this extension is a driver and its name is \"horace\", the CLI args would be --driver-horace-test-web-server-port and --driver-horace-test-web-server-host , respectively. Alternatively, a user could provide a configuration file containing: { \"server\" : { \"driver\" : { \"horace\" : { \"test-web-server-port\" : 1234 , \"test-web-server-host\" : \"localhorse\" } } } }","title":"Add a schema for custom command line arguments"},{"location":"ecosystem/build-drivers/#add-driver-scripts","text":"Sometimes you might want users of your driver to be able to run scripts outside the context of a session (for example, to run a script that pre-builds aspects of your driver). To support this, you can add a map of script names and JS files to the scripts field within your Appium extension metadata. So let's say you've created a script in your project that lives in a scripts directory in your project, named driver-prebuild.js . Then you could add a scripts field like this: { \"scripts\" : { \"prebuild\" : \"./scripts/driver-prebuild.js\" } } Now, assuming your driver is named mydriver , users of your driver can run appium driver run mydriver prebuild , and your script will execute.","title":"Add driver scripts"},{"location":"ecosystem/build-drivers/#proxy-commands-to-another-webdriver-implementation","text":"A very common design architecture for Appium drivers is to have some kind of platform-specific WebDriver implementation that the Appium driver interfaces with. For example, the Appium UiAutomator2 driver interfaces with a special (Java-based) server running on the Android device. In webview mode, it also interfaces with Chromedriver. If you find yourself in this situation, it is extremely easy to tell Appium that your driver is just going to be proxying WebDriver commands straight to another endpoint. First, let Appium know that your driver can proxy by implementing the canProxy method: canProxy () { return true ; } Next, tell Appium which WebDriver routes it should not attempt to proxy (there often end up being certain routes that you don't want to forward on): getProxyAvoidList () { return [ [ 'POST' , new RegExp ( '^/session/[^/]+/appium' )] ]; } The proxy avoidance list should be an array of arrays, where each inner array has an HTTP method as its first member, and a regular expression as its second. If the regular expression matches the route, then the route will not be proxied and instead will be handled by your driver. In this example, we are avoiding proxying all POST routes that have the appium prefix. Next, we have to set up the proxying itself. The way to do this is to use a special class from Appium called JWProxy . (The name means \"JSON Wire Proxy\" and is related to a legacy implementation of the protocol). You'll want to create a JWProxy object using the details required to connect to the remote server: // import {JWProxy} from 'appium/driver'; const proxy = new JWProxy ({ server : 'remote.server' , port : 1234 , base : '/' , }); this . proxyReqRes = proxy . proxyReqRes . bind ( proxy ); this . proxyCommand = proxy . command . bind ( proxy ); Here we are creating a proxy object and assigning some of its methods to this under the names proxyReqRes and proxyCommand . This is required for Appium to use the proxy, so don't forget this step! The JWProxy has a variety of other options which you can check out in the source code, as well. (TODO: publish options as API docs and link here). Finally, we need a way to tell Appium when the proxy is active. For your driver it might always be active, or it might only be active when in a certain context. You can define the logic as an implementation of proxyActive : proxyActive () { return true ; // or use custom logic } With those pieces in play, you won't have to reimplement anything that's already implemented by the remote endpoint you're proxying to. Appium will take care of all the proxying for you.","title":"Proxy commands to another WebDriver implementation"},{"location":"ecosystem/build-drivers/#extend-the-existing-protocol-with-new-commands","text":"You may find that the existing commands don't cut it for your driver. If you want to expose behaviours that don't map to any of the existing commands, you can create new commands in one of two ways: Extending the WebDriver protocol and creating client-side plugins to access the extensions Overloading the Execute Script command by defining \"Execute Methods\" If you want to follow the first path, you can direct Appium to recognize new methods and add them to its set of allowed HTTP routes and command names. You do this by assigning the newMethodMap static variable in your driver class to an object of the same form as Appium's routes.js object. For example, here is the newMethodMap for the FakeDriver example driver: static newMethodMap = { '/session/:sessionId/fakedriver' : { GET : { command : 'getFakeThing' }, POST : { command : 'setFakeThing' , payloadParams : { required : [ 'thing' ]}}, }, '/session/:sessionId/fakedriverargs' : { GET : { command : 'getFakeDriverArgs' }, }, }; In this example we're adding a few new routes and a total of 3 new commands. For more examples of how to define commands in this way, it's best to have a look through routes.js . Now all you need to do is implement the command handlers in the same way you'd implement any other Appium command. The downside of this way of adding new commands is that people using the standard Appium clients won't have nice client-side functions designed to target these endpoints. So you would need to create and release client-side plugins for each language you want to support (directions or examples can be found at the relevant client docs). An alternative to this way of doing things is to overload a command which all WebDriver clients have access to already: Execute Script. Appium provides some a convenient tool for making this easy. Let's say you are building a driver for stereo system called soundz , and you wanted to create a command for playing a song by name. You could expose this to your users in such a way that they call something like: // webdriverio example. Calling webdriverio's `executeScript` command is what trigger's Appium's // Execute Script command handler driver . executeScript ( 'soundz: playSong' , [{ song : 'Stairway to Heaven' , artist : 'Led Zeppelin' }]); Then in your driver code you can define the static property executeMethodMap as a mapping of script names to methods on your driver. It has the same basic form as newMethodMap , described above. Once executeMethodMap is defined, you'll also need to implement the Execute Script command handler, which according to Appium's routes mapping is called execute . The implementation can call a single helper function, this.executeMethod , which takes care of looking at the script and arguments the user sent in and routing it to the correct custom handler you've defined. Here's an example: static executeMethodMap = { 'soundz: playSong' , { command : 'soundzPlaySong' , params : { required : [ 'song' , 'artist' ], optional : []}, } } async soundzPlaySong ( song , artist ) { // play the song based on song and artist details } async execute ( script , args ) { return await this . executeMethod ( script , args ); } A couple notes about this system: 1. The arguments array sent via the call to Execute Script must contain only zero or one element(s). The first item in the list is considered to be the parameters object for your method. These parameters will be parsed, validated, and then applied to your overload method in the order specified in executeMethodMap (the order specified in the required parameters list, followed by the optional parameters list). I.e., this framework assumes only a single actual argument sent in via Execute Script (and this argument should be an object with keys/values representing the parameters your execute method expects). 1. Appium does not automatically implement execute (the Execute Script handler) for you. You may wish, for example, to only call the executeMethod helper function when you're not in proxy mode! 1. The executeMethod helper will reject with an error if a script name doesn't match one of the script names defined as a command in executeMethodMap , or if there are missing parameters.","title":"Extend the existing protocol with new commands"},{"location":"ecosystem/build-drivers/#implement-handling-of-appium-settings","text":"Appium users can send parameters to your driver via CLI args as well as via capabilities. But these cannot change during the course of a test, and sometimes users want to adjust parameters mid-test. Appium has a Settings API for this purpose. To support settings in your own driver, first of all define this.settings to be an instance of the appropriate class, in your constructor: // import {DeviceSettings} from 'appium/driver'; this . settings = new DeviceSettings (); Now, you can read user settings any time simply by calling this.settings.getSettings() . This will return a JS object where the settings names are keys and have their corresponding values. If you want to assign some default settings, or run some code on your end whenever settings are updated, you can do both of these things as well. constructor () { const defaults = { setting1 : 'value1' }; this . settings = new DeviceSettings ( defaults , this . onSettingsUpdate . bind ( this )); } async onSettingsUpdate ( key , value ) { // do anything you want here with key and value }","title":"Implement handling of Appium settings"},{"location":"ecosystem/build-drivers/#make-itself-aware-of-resources-other-concurrent-drivers-are-using","text":"Let's say your driver uses up some system resources, like ports. There are a few ways to make sure that multiple simultaneous sessions don't use the same resources: Have your users specify resource IDs via capabilities ( appium:driverPort etc) Just always use free resources (find a new random port for each session) Have each driver express what resources it is using, then examine currently-used resources from other drivers when a new session begins. To support this third strategy, you can implement get driverData in your driver to return what sorts of resources your driver is currently using, for example: get driverData () { return { specialPort : 1234 , specialFile : /path/to/file} } Now, when a new session is started on your driver, the driverData response from any other simultaneously running drivers (of the same type) will also be included, as the last parameter of the createSession method: async createSession ( jwpCaps , reqCaps , w3cCaps , driverData ) You can dig into this driverData array to see what resources other drivers are using to help determine which ones you want to use for this particular session. Warning Be careful here, since driverData is only passed between sessions of a single running Appium server. There's nothing to stop a user from running multiple Appium servers and requesting your driver simultaneously on each of them. In this case, you won't be able to ensure independence of resources via driverData , so you might consider using file-based locking mechanisms or something similar. Warning It's also important to note you will only receive driverData for other instances of your driver. So unrelated drivers also running may still be using some system resources. In general Appium doesn't provide any features for ensuring unrelated drivers don't interfere with one another, so it's up to the drivers to allow users to specify resource locations or addresses to avoid clashes.","title":"Make itself aware of resources other concurrent drivers are using"},{"location":"ecosystem/build-drivers/#log-events-to-the-appium-event-timeline","text":"Appium has an Event Timing API which allows users to get timestamps for certain server-side events (like commands, startup milestones, etc...) and display them on a timeline. The feature basically exists to allow introspection of timing for internal events to help with debugging or running analysis on Appium driver internals. You can add your own events to the event log: this . logEvent ( name ); Simply provide a name for the event and it will be added at the current time, and made accessible as part of the event log for users.","title":"Log events to the Appium event timeline"},{"location":"ecosystem/build-drivers/#hide-behaviour-behind-security-flags","text":"Appium has a feature-flag based security model that allows driver authors to hide certain features behind security flags. What this means is that if you have a feature you deem insecure and want to require server admins to opt in to it, you can require that they enable the feature by adding it to the --allow-insecure list or turning off server security entirely. To support the check within your own driver, you can call this.isFeatureEnabled(featureName) to determine whether a feature of the given name has been enabled. Or, if you want to simply short-circuit and throw an error if the feature isn't enabled, you can call this.assertFeatureEnabled(featureName) .","title":"Hide behaviour behind security flags"},{"location":"ecosystem/build-drivers/#use-a-temp-dir-for-files","text":"If you want to use a temporary directory for files your driver creates that are not important to keep around between computer or server restarts, you can simply read from this.opts.tmpDir . This reads the temporary directory location from @appium/support , potentially overridden by a CLI flag. I.e., it's safer than writing to your own temporary directory because the location here plays nicely with possible user configuration. this.opts.tmpDir is a string, the path to the dir.","title":"Use a temp dir for files"},{"location":"ecosystem/build-drivers/#deal-with-unexpected-shutdowns-or-crashes","text":"Your driver might run into a situation where it can't continue operating normally. For example, it might detect that some external service has crashed and nothing will work anymore. In this case, it can call this.startUnexpectedShutdown(err) with an error object including any details, and Appium will attempt to gracefully handle any remaining requests before shutting down the session. If you want to perform some of your own cleanup logic when you encounter this condition, you can either do so immediately before calling this.startUnexpectedShutdown , or you can attach a handler to the unexpected shutdown event and run your cleanup logic \"out of band\" so to speak: this . onUnexpectedShutdown ( handler ) handler should be a function which receives an error object (representing the reason for the unexpected shutdown).","title":"Deal with unexpected shutdowns or crashes"},{"location":"ecosystem/build-plugins/","text":"TODO","title":"Building Appium Plugins"},{"location":"guides/caps/","text":"TODO Special Notes for Cloud Providers When managing an Appium cloud, your users may wish to target various independent versions of Appium drivers and plugins. It is of course up to each service provider how they wish to implement the discovery, installation, and availability of any official or third party drivers or plugins. But the Appium team makes the following recommendations in terms of the capabilities service providers support, for consistency across the industry. This is a recommendation only, and not a standard, but adopting it will help users to navigate the increased complexity that working with Appium 2.0 in a cloud environment may bring. Suggested capabilities In addition to the standard platformName , appium:deviceName , appium:automationName , and appium:platformVersion , we recommend adopting the capability $cloud:appiumOptions , where the label $cloud is not meant to be interpreted literally but instead should be replaced by your vendor prefix (so for HeadSpin it would be headspin , Sauce Labs it would be sauce , and BrowserStack it would be browserstack , to name just a few examples). The $cloud:appiumOptions capability would itself be a JSON object, with the following internal keys: Capability Used for Example version Designating which version of the Appium server is used to host and manage drivers. If ommitted, behavior left up to the provider, but the recommendation would be to provide the latest official version. 2.0.0 automationVersion Designating which version of the specified driver should be used. 1.55.2 automation Designating a custom driver to use (see below for more info). This would override appium:automationName and $cloud:automationVersion {\"name\": \"@org/custom-driver\", \"source\": \"github\", \"package\": \"custom-driver\"} plugins Designating the list of plugins (and potentially versions of plugins) to be activated (see below for more info). [\"images\", \"universal-xml\"] Basic example Appium extensions (drivers and plugins) have a set of properties that specify where they can be installed from. Cloud providers are obviously under no obligation to provide support for arbitrarily specified extensions, seeing as these may represent untrusted code running in a managed environment. In the case where arbitrary extensions are not supported, the appium:automationName , $cloud:automationVersion , and $cloud:appiumPlugins capabilities should be sufficient. See the following JSON object representing capabilities for a session: { \"platformName\" : \"iOS\" , \"appium:platformVersion\" : \"14.4\" , \"appium:deviceName\" : \"iPhone 11\" , \"appium:app\" : \"Some-App.app.zip\" , \"appium:automationName\" : \"XCUITest\" , \"$cloud:appiumOptions\" : { \"appiumVersion\" : \"2.0.0\" , \"automationVersion\" : \"3.52.0\" , \"plugins\" : [ \"images\" ] } } This set of capabilities requests an Appium 2+ server supporting the XCUITest driver at version 3.52.0 , and the images plugin active. This set is easy for a cloud provider to verify. The cloud provider can obviously do anything it wants in response to these capabilities, including downloading Appium and driver and plugin packages on the fly, or erroring out if the versions requested are not in a supported set, or if the plugin is not supported, etc... Basic example with appium:options The previous example still looks a bit disorganized, so of course we also recommend that cloud providers support the appium:options capability as detailed above, which could turn the previous set of capabilities into the following: { \"platformName\" : \"iOS\" , \"appium:options\" : { \"platformVersion\" : \"14.4\" , \"deviceName\" : \"iPhone 11\" , \"app\" : \"Some-App.app.zip\" , \"automationName\" : \"XCUITest\" }, \"$cloud:appiumOptions\" : { \"appiumVersion\" : \"2.0.0\" , \"automationVersion\" : \"3.52.0\" , \"plugins\" : [ \"images\" ] } } Extension objects Some service providers may wish to dynamically allow access to all of the features of the Appium 2.0 CLI, including downloading arbitrary drivers and plugins. To represent these extensions, we can define special JSON \"extension objects\", with the following keys: name : the name of the extension. This would be an NPM package name (if downloading from NPM), or a git or GitHub spec (if downloading from a git server or GitHub). version : the version of the extension, e.g., the NPM package version or Git SHA. (optional) source : a denotation of where the extension can be downloaded from. Recommended to support the following values: appium , npm , git , github . Here, appium means \"Appium's own official list\", and should be the default value if this key is not included. (optional) package : when downloading extensions from git or github, the NPM package name of the extension must also be provided. This is optional for non-git sources. Since each session is handled by a single driver, the $cloud:appiumOptions / $automation capability could be used with an extension object value to denote this driver, for example: { \"$cloud:appiumOptions\" : { \"automation\" : { \"name\" : \"git+https://some-git-host.com/custom-driver-project.git\" , \"version\" : \"some-git-sha\" , \"source\" : \"git\" , \"package\" : \"driver-npm-package-name\" } } } And since sessions can handle multiple plugins, each value in the list of $cloud:appiumPlugins could also be an extension object rather than a string, so that specific versions could be requested: { \"$cloud:appiumOptions\" : { \"plugins\" : [{ \"name\" : \"images\" , \"version\" : \"1.1.0\" }, { \"name\" : \"my-github-org/my-custom-plugin\" , \"version\" : \"a83f2e\" , \"source\" : \"github\" , \"package\" : \"custom-plugin\" }] } } These serve as illustrative examples for the recommendations here. Of course it is up to the service providers to implement the handling of these capabilities at their front end / load balancer, to perform any error checking, or to actually run any of the appium driver or appium plugin CLI commands that support the end user's request. This section is merely a suggestion as to how service providers might design their user-facing capabilities API in a way which in principle supports all of the capabilities Appium itself would provide to the end user if they were running Appium on their own.","title":"Capabilities"},{"location":"guides/caps/#special-notes-for-cloud-providers","text":"When managing an Appium cloud, your users may wish to target various independent versions of Appium drivers and plugins. It is of course up to each service provider how they wish to implement the discovery, installation, and availability of any official or third party drivers or plugins. But the Appium team makes the following recommendations in terms of the capabilities service providers support, for consistency across the industry. This is a recommendation only, and not a standard, but adopting it will help users to navigate the increased complexity that working with Appium 2.0 in a cloud environment may bring.","title":"Special Notes for Cloud Providers"},{"location":"guides/caps/#suggested-capabilities","text":"In addition to the standard platformName , appium:deviceName , appium:automationName , and appium:platformVersion , we recommend adopting the capability $cloud:appiumOptions , where the label $cloud is not meant to be interpreted literally but instead should be replaced by your vendor prefix (so for HeadSpin it would be headspin , Sauce Labs it would be sauce , and BrowserStack it would be browserstack , to name just a few examples). The $cloud:appiumOptions capability would itself be a JSON object, with the following internal keys: Capability Used for Example version Designating which version of the Appium server is used to host and manage drivers. If ommitted, behavior left up to the provider, but the recommendation would be to provide the latest official version. 2.0.0 automationVersion Designating which version of the specified driver should be used. 1.55.2 automation Designating a custom driver to use (see below for more info). This would override appium:automationName and $cloud:automationVersion {\"name\": \"@org/custom-driver\", \"source\": \"github\", \"package\": \"custom-driver\"} plugins Designating the list of plugins (and potentially versions of plugins) to be activated (see below for more info). [\"images\", \"universal-xml\"]","title":"Suggested capabilities"},{"location":"guides/caps/#basic-example","text":"Appium extensions (drivers and plugins) have a set of properties that specify where they can be installed from. Cloud providers are obviously under no obligation to provide support for arbitrarily specified extensions, seeing as these may represent untrusted code running in a managed environment. In the case where arbitrary extensions are not supported, the appium:automationName , $cloud:automationVersion , and $cloud:appiumPlugins capabilities should be sufficient. See the following JSON object representing capabilities for a session: { \"platformName\" : \"iOS\" , \"appium:platformVersion\" : \"14.4\" , \"appium:deviceName\" : \"iPhone 11\" , \"appium:app\" : \"Some-App.app.zip\" , \"appium:automationName\" : \"XCUITest\" , \"$cloud:appiumOptions\" : { \"appiumVersion\" : \"2.0.0\" , \"automationVersion\" : \"3.52.0\" , \"plugins\" : [ \"images\" ] } } This set of capabilities requests an Appium 2+ server supporting the XCUITest driver at version 3.52.0 , and the images plugin active. This set is easy for a cloud provider to verify. The cloud provider can obviously do anything it wants in response to these capabilities, including downloading Appium and driver and plugin packages on the fly, or erroring out if the versions requested are not in a supported set, or if the plugin is not supported, etc...","title":"Basic example"},{"location":"guides/caps/#basic-example-with-appiumoptions","text":"The previous example still looks a bit disorganized, so of course we also recommend that cloud providers support the appium:options capability as detailed above, which could turn the previous set of capabilities into the following: { \"platformName\" : \"iOS\" , \"appium:options\" : { \"platformVersion\" : \"14.4\" , \"deviceName\" : \"iPhone 11\" , \"app\" : \"Some-App.app.zip\" , \"automationName\" : \"XCUITest\" }, \"$cloud:appiumOptions\" : { \"appiumVersion\" : \"2.0.0\" , \"automationVersion\" : \"3.52.0\" , \"plugins\" : [ \"images\" ] } }","title":"Basic example with appium:options"},{"location":"guides/caps/#extension-objects","text":"Some service providers may wish to dynamically allow access to all of the features of the Appium 2.0 CLI, including downloading arbitrary drivers and plugins. To represent these extensions, we can define special JSON \"extension objects\", with the following keys: name : the name of the extension. This would be an NPM package name (if downloading from NPM), or a git or GitHub spec (if downloading from a git server or GitHub). version : the version of the extension, e.g., the NPM package version or Git SHA. (optional) source : a denotation of where the extension can be downloaded from. Recommended to support the following values: appium , npm , git , github . Here, appium means \"Appium's own official list\", and should be the default value if this key is not included. (optional) package : when downloading extensions from git or github, the NPM package name of the extension must also be provided. This is optional for non-git sources. Since each session is handled by a single driver, the $cloud:appiumOptions / $automation capability could be used with an extension object value to denote this driver, for example: { \"$cloud:appiumOptions\" : { \"automation\" : { \"name\" : \"git+https://some-git-host.com/custom-driver-project.git\" , \"version\" : \"some-git-sha\" , \"source\" : \"git\" , \"package\" : \"driver-npm-package-name\" } } } And since sessions can handle multiple plugins, each value in the list of $cloud:appiumPlugins could also be an extension object rather than a string, so that specific versions could be requested: { \"$cloud:appiumOptions\" : { \"plugins\" : [{ \"name\" : \"images\" , \"version\" : \"1.1.0\" }, { \"name\" : \"my-github-org/my-custom-plugin\" , \"version\" : \"a83f2e\" , \"source\" : \"github\" , \"package\" : \"custom-plugin\" }] } } These serve as illustrative examples for the recommendations here. Of course it is up to the service providers to implement the handling of these capabilities at their front end / load balancer, to perform any error checking, or to actually run any of the appium driver or appium plugin CLI commands that support the end user's request. This section is merely a suggestion as to how service providers might design their user-facing capabilities API in a way which in principle supports all of the capabilities Appium itself would provide to the end user if they were running Appium on their own.","title":"Extension objects"},{"location":"guides/config/","text":"Instead of passing arguments on the command line to Appium, you may add them to a special config file. Appium will read values from this config file when it runs. (Please note that CLI arguments have precedence over configuration files; if a value is set in a config file and via CLI argument, the CLI argument is preferred.) Supported Config File Formats You can store your config data in the following kinds of files: JSON YAML JS (a JavaScript file exporting a JS object) CJS (the same as above; the extension is for common JS) Warning Note: Configuration files in ESM format are not currently supported. Supported Config File Locations Configuration files can be named anything, but the following filenames will be automatically discovered and loaded by Appium: .appiumrc.json (recommended) .appiumrc.yaml .appiumrc.yml .appiumrc.js .appiumrc.cjs appium.config.js appium.config.cjs .appiumrc (which is considered to be JSON) Further, if your project uses Node.js, you can use store the configuration inside an appium property in your package.json and it will be automatically discovered. Config File Search Appium will search up the directory tree from the current working directory for one of these files. If it reaches the current user's home directory or filesystem root, it will stop looking. To specify a custom location for your config file, use appium --config-file /path/to/config/file . Configuration File Format First, you might want to look at some examples: Appium Configuration - JSON Appium Configuration - YAML Appium Configuration - JS A description of the format is available, as well: Appium Configuration File JSON Schema TypeScript declarations for Appium Configuration To describe in words, the config file will have a root server property, and all arguments are child properties. For certain properties which must be supplied on the command-line as comma-delimited lists, JSON strings, and/or external filepaths, these instead will be of their \"native\" type. For example, --use-plugins <value> needs <value> to be comma-delimited string or path to a delimited file. However, the config file just wants an array, e.g.,: { \"server\" : { \"use-plugins\" : [ \"my-plugin\" , \"some-other-plugin\" ] } } Configuring extensions (drivers and plugins) For driver -and- plugin -specific configuration, these live under the server.driver and server.plugin properties, respectively. Each driver or plugin will have its own named property, and the values of any specific configuration it provides are under this. For example: { \"server\" : { \"driver\" : { \"xcuitest\" : { \"webkit-debug-proxy-port\" : 5400 } } } } Note The above configuration corresponds to the --driver-xcuitest-webkit-debug-proxy-port CLI argument. All properties are case-sensitive and will be in kebab-case . For example, callback-port is allowed, but callbackPort is not.","title":"The Appium Config File"},{"location":"guides/config/#supported-config-file-formats","text":"You can store your config data in the following kinds of files: JSON YAML JS (a JavaScript file exporting a JS object) CJS (the same as above; the extension is for common JS) Warning Note: Configuration files in ESM format are not currently supported.","title":"Supported Config File Formats"},{"location":"guides/config/#supported-config-file-locations","text":"Configuration files can be named anything, but the following filenames will be automatically discovered and loaded by Appium: .appiumrc.json (recommended) .appiumrc.yaml .appiumrc.yml .appiumrc.js .appiumrc.cjs appium.config.js appium.config.cjs .appiumrc (which is considered to be JSON) Further, if your project uses Node.js, you can use store the configuration inside an appium property in your package.json and it will be automatically discovered.","title":"Supported Config File Locations"},{"location":"guides/config/#config-file-search","text":"Appium will search up the directory tree from the current working directory for one of these files. If it reaches the current user's home directory or filesystem root, it will stop looking. To specify a custom location for your config file, use appium --config-file /path/to/config/file .","title":"Config File Search"},{"location":"guides/config/#configuration-file-format","text":"First, you might want to look at some examples: Appium Configuration - JSON Appium Configuration - YAML Appium Configuration - JS A description of the format is available, as well: Appium Configuration File JSON Schema TypeScript declarations for Appium Configuration To describe in words, the config file will have a root server property, and all arguments are child properties. For certain properties which must be supplied on the command-line as comma-delimited lists, JSON strings, and/or external filepaths, these instead will be of their \"native\" type. For example, --use-plugins <value> needs <value> to be comma-delimited string or path to a delimited file. However, the config file just wants an array, e.g.,: { \"server\" : { \"use-plugins\" : [ \"my-plugin\" , \"some-other-plugin\" ] } }","title":"Configuration File Format"},{"location":"guides/config/#configuring-extensions-drivers-and-plugins","text":"For driver -and- plugin -specific configuration, these live under the server.driver and server.plugin properties, respectively. Each driver or plugin will have its own named property, and the values of any specific configuration it provides are under this. For example: { \"server\" : { \"driver\" : { \"xcuitest\" : { \"webkit-debug-proxy-port\" : 5400 } } } } Note The above configuration corresponds to the --driver-xcuitest-webkit-debug-proxy-port CLI argument. All properties are case-sensitive and will be in kebab-case . For example, callback-port is allowed, but callbackPort is not.","title":"Configuring extensions (drivers and plugins)"},{"location":"guides/context/","text":"TODO","title":"The Context API"},{"location":"guides/event-timing/","text":"Appium comes with the ability to retrieve timing information about startup information and command length. This is an advanced feature that is controlled by the use of the appium:eventTimings capability (set it to true to log event timings). With this capability turned on, the GET /session/:id response (i.e., the response to driver.getSessionDetails() or similar, depending on client) will be decorated with an events property. This is the structure of that events property: { \"<event_type>\": [<occurence_timestamp_1>, ...], \"commands\": [ { \"cmd\": \"<command_name>\", \"startTime\": <js_timestamp>, \"endTime\": <js_timestamp> }, ... ] } In other words, the events property has 2 kinds of properties of its own: Properties which are the names of event types The commands property Properties which are names of event types correspond to an array of timestamps when that event happened. It's an array because events might happen multiple times in the course of a session. Examples of event types include: newSessionRequested newSessionStarted (Individual drivers will define their own event types, so we do not have an exhaustive list to share here. It's best to actually get one of these responses from a real session to inspect the possible event types.) The commands property is an array of objects. Each object has the name of the Appium-internal command (for example click ), as well as the time the command started processing and the time it finished processing. With this data, you can calculate the time between events, or a strict timeline of events, or statistical information about average length of a certain type of command, and so on. You can only receive data about events that have happened when you make the call to /session/:id , so the best time to get data about an entire session is right before quitting it. The Appium team maintains an event timings parser tool that can be used to generate various kinds of reports from event timings output: appium/appium-event-parser . Add a custom event TODO The links to the commands in the following paragraph do not yet work since these docs are under construction. You can add custom events that will show up in the event timings data. You can send a custom event name to the Appium server using the Log Event API , and the server will store the timestamp. The Get Events command can be used to retrieve named events' timestamps later on.","title":"The Event Timing API"},{"location":"guides/event-timing/#add-a-custom-event","text":"TODO The links to the commands in the following paragraph do not yet work since these docs are under construction. You can add custom events that will show up in the event timings data. You can send a custom event name to the Appium server using the Log Event API , and the server will store the timestamp. The Get Events command can be used to retrieve named events' timestamps later on.","title":"Add a custom event"},{"location":"guides/execute-script-overload/","text":"TODO","title":"Execute Script Overloads"},{"location":"guides/grid/","text":"TODO","title":"Appium and Selenium Grid"},{"location":"guides/log-filters/","text":"TODO","title":"Log Filtering"},{"location":"guides/managing-exts/","text":"TODO","title":"Managing Appium Drivers and Plugins"},{"location":"guides/migrating-1-to-2/","text":"This document is a guide for those who are using Appium 1.x and wish to migrate to Appium 2.x. It contains a list of breaking changes and how to migrate your environments or test suites to ensure compatibility with Appium 2.0. Overview of Appium 2.0 Appium 2.0 is the most major new release of Appium in over 5 years. The changes in Appium 2.0 are not primarily related to changes in automation behaviors for specific platforms. Instead, Appium 2.0 reenvisions Appium as a platform where \"drivers\" (code projects that introduce support for automation of a given platform) and \"plugins\" (code projects that allow for overriding, altering, extending, or adding behaviors to Appium) can be easily created and shared. At the same time, the Appium project is taking the opportunity to remove many old and deprecated bits of functionality. Together these do introduce a few breaking changes to how Appium is installed, how drivers and various features are managed, and protocol support. These are detailed below. Breaking Changes Have a look at the Appium 2.0 release notes for the most comprehensive lists of changes. Here we call out the breaking changes and what you need to do do account for them. Installing drivers during setup When you installed Appium 1.x, all available drivers would be installed at the same time as the main Appium server. This is no longer the case. Simply installing Appium 2.0 (e.g., by npm install -g appium ), will install the Appium server only, but no drivers. To install drivers, you must instead use the new Appium extension CLI . For example, to install the latest versions of the XCUITest and UiAutomator2 drivers, after installing Appium you would run the following commands: appium driver install xcuitest appium driver install uiautomator2 At this point, your drivers are installed and ready. There's a lot more you can do with this CLI so be sure to check out the docs on it. If you're running in a CI environment or want to install Appium along with some drivers all in one step, you can do so using some special flags during install, for example: npm install --global appium --drivers=xcuitest,uiautomator2 This will install Appium and the two drivers for you in one go. Chromedriver installation flags In Appium 1.x it was possible to customize the way Chromedriver was installed (as part of the UiAutomator2 driver for example), using the following command line flags: --chromedriver-skip-install --chromedriver-version --chromedriver-cdnurl Because Appium 2.0 now installs drivers for you, and because these flags were implemented as NPM config flags, they will no longer work. Instead, use the following environment variables during driver installation: APPIUM_SKIP_CHROMEDRIVER_INSTALL CHROMEDRIVER_VERSION CHROMEDRIVER_CDNURL For example: APPIUM_SKIP_CHROMEDRIVER_INSTALL=1 appium driver install uiautomator2 Driver-specific command line options With Appium 1.x, command-line options specific to particular drivers were all hosted on the main Appium server. So, for example, --chromedriver-executable was a CLI parameter you could use with Appium to set the location of a specific Chromedriver version for use with, say, the UiAutomator2 driver. With Appium 2.x, all driver- and platform-specific CLI params have been moved to the drivers themselves. To access them, you'll now need to prepend the argument with the extension type (either driver or plugin ) and the name of the extension. For example, --chromedriver-executable becomes --driver-uiautomator2-chromedriver-executable . Driver-specific automation commands The definition of certain commands that pertain only to specific drivers has been moved to those drivers' implementations. For example, pressKeyCode is specific to the UiAutomator2 driver and is now understood only by that driver. In practice, the only breaking change here is the kind of error you would encounter if the appropriate driver is not installed. Previously, you would get a 501 Not Yet Implemented error if using a driver that didn't implement the command. Now, you will get a 404 Not Found error because if a driver that doesn't know about the command is not active, the main Appium server will not define the route corresponding to the command. Driver updates In the past, to get updates to your iOS or Android drivers, you'd simply wait for those updates to be rolled into a new release of Appium, and then update your Appium version. With Appium 2.x, the Appium server and the Appium drivers are versioned and released separately. This means that drivers can be on their own release cadence and that you can get driver updates as they happen, rather than waiting for a new Appium server release. The way to check for driver updates is with the CLI: appium driver list --updates If any updates are available, you can then run the update command for any given driver: appium driver update xcuitest (For a complete description of the update command, check out the Extension CLI doc) To update the Appium server itself, you do the same thing as in the past: npm install -g appium . Now, installing new versions of the Appium server will leave your drivers intact, so the whole process will be much more quick. Protocol changes Appium's API is based on the W3C WebDriver Protocol , and it has supported this protocol for years. Before the W3C WebDriver Protocol was designed as a web standard, several other protocols were used for both Selenium and Appium. These protocols were the \"JSONWP\" (JSON Wire Protocol) and \"MJSONWP\" (Mobile JSON Wire Protocol). The W3C Protocol differs from the (M)JSONWP protocols in a few small ways. Up until Appium 2.0, Appium supported both protocols, so that older Selenium/Appium clients could still communicate with newer Appium servers. Moving forward, support for older protocols will be removed. Capabilities One significant difference between old and new protocols is in the format of capabilities. Previously called \"desired capabilities\", and now called simply \"capabilities\", there is now a requirement for a so-called \"vendor prefix\" on any non-standard capabilities. The list of standard capabilities is given in the WebDriver Protocol spec , and includes a few commonly used capabilities such as browserName and platformName . These standard capabilities continue to be used as-is. All other capabilities must include a \"vendor prefix\" in their name. A vendor prefix is a string followed by a colon, such as appium: . Most of Appium's capabilities go beyond the standard W3C capabilities and must therefore include vendor prefixes (we recommend that you use appium: unless directed otherwise by documentation). For example: appium:app appium:noReset appium:deviceName This requirement may or may not be a breaking change for your test suites when targeting Appium 2.0. If you're using an updated Appium client, the client will add the appium: prefix for you on all necessary capabilities. New versions of the Appium Inspector tool will also do this. Cloud-based Appium providers may also do this. So simply be aware that if you get any messages to the effect that your capabilities lack a vendor prefix, this is how you solve that problem. On a related note, it will no longer be possible to start Appium sessions using WebDriver clients that don't support the W3C protocol (see below for a comment to this effect for the WD library). To make everyone's lives a bit easier, we've also introduced the option of wrapping up all Appium-related capabilities into one object capability, appium:options . You can bundle together anything that you would normally put an appium: prefix on into this one capability. Here's an example (in raw JSON) of how you might start an iOS session on the Safari browser using appium:options : { \"platformName\" : \"iOS\" , \"browserName\" : \"Safari\" , \"appium:options\" : { \"platformVersion\" : \"14.4\" , \"deviceName\" : \"iPhone 11\" , \"automationName\" : \"XCUITest\" } } (Of course, each client will have a different way of creating structured capabilities like appium:options or other ones that you might have seen such as goog:chromeOptions ). NB: capabilities that show up in appium:options will overwrite capabilities of the same name that show up at the top level of the object. For more information on capabilities, have a look at the Capabilities Guide . Removed Commands In addition to commands which have been moved to driver implementations, commands which were a part of the old JSON Wire Protocol and not a part of the W3C Protocol are no longer available: TODO (these commands are being identified and removed and will be updated here when complete) If you use a modern Appium or Selenium client, you should no longer have access to these anyway, so any breaking changes should appear on the client side first and foremost. Image analysis features moved to plugin One of the design goals for Appium 2.0 is to migrate non-core features into special extensions called plugins . This allows people to opt into features which require extra time to download or extra system setup. The various image-related features of Appium (image comparison, finding elements by image, etc...) have been moved into an officially supported plugin called images . If you use these image-related methods, to continue accessing them you will need to do two things. Install the plugin: appium plugin install images Ensure you start the Appium server with access to run the plugin by including it in the list of plugins designated on the command line, e.g., appium --use-plugins=images Image-related commands will also be removed on the client side of things, which means you will need to follow the instructions on the plugin README for installing client-side plugins to access these features. Execute Driver Script command moved to plugin If you use the advanced Execute Driver Script feature (which allows you to send in a WebdriverIO script to have it executed completely on the server instead of command-by-command from the client), this functionality has been moved to a plugin. Here's what to do to keep using it: Install the plugin: appium plugin install execute-driver Ensure you start the Appium server with access to run the plugin by including it in the list of plugins designated on the command line, e.g., appium --use-plugins=execute-driver External Files No Longer Supported for --nodeconfig , --default-capabilities , --allow-insecure and --deny-insecure These options can be provided as strings on the command line (a JSON string for --nodeconfig and a comma-separated list of strings for --allow-insecure and --deny-insecure ). Arguments provided on the command line will likely need to be quoted or escaped. The recommended method to provide these options is now via a configuration file . In summary, if you are using a JSON Appium config file, you can simply cut-and-paste the contents of your \"nodeconfig\" JSON file into the value of the server.nodeconfig property. Any CSV-like files you had previously provided for --allow-insecure and --deny-insecure become the values of the server.allow-insecure and server.deny-insecure properties in the Appium config files (respectively); both are arrays of strings. Old drivers removed The old iOS and Android (UiAutomator 1) drivers and related tools (e.g., authorize-ios ) have been removed. They haven't been relevant for many years anyway. Internal packages renamed Some Appium-internal NPM packages have been renamed (for example, appium-base-driver is now @appium/base-driver ). This is not a breaking change for Appium users, only for people who have built software that directly incorporates Appium's code. \"WD\" JavaScript client library no longer supported For many years, some of Appium's authors maintained the WD client library. This library has been deprecated and has not been updated for use with the W3C WebDriver protocol. As such, if you're using this library you'll need to move to a more modern one. We recommend WebdriverIO . Appium Inspector split out from Appium Desktop The inspecting portion of Appium Desktop has been moved to its own app, Appium Inspector: github.com/appium/appium-inspector . It's fully compatible with Appium 2.0 servers. Simply download it and run it on its own. You no longer need the GUI Appium Desktop server to inspect apps. The Appium Desktop server will continue to be supported at its original site: github.com/appium/appium-desktop . It will simply no longer bundle the Inspector with it. You can also now use the Appium Inspector without downloading anything, by visiting the web version of Appium Inspector . Note that to test against local servers, you'll need to start the server with --allow-cors so that the browser-based version of Appium Inspector can access your Appium server to start sessions. Major New Features Apart from the breaking changes mentioned above, in this section is a list of some of the major new features you may wish to take advantage of with Appium 2.0. Plugins Server Plugins Appium extension authors can now develop their own server plugins, which can intercept and modify any Appium command, or even adjust the way the underlying Appium HTTP server itself works. To learn more about plugins, read the new Appium Introduction . Interested in building a plugin? Check out the Building Plugins guide. Client Plugins TODO Install drivers and plugins from anywhere You're no longer limited to the drivers that come with Appium, or that the Appium team even knows about! Appium extension authors can now develop custom drivers, which can be downloaded or installed via Appium's Extension CLI from NPM, Git, GitHub, or even the local filesystem. Interested in building a driver? Check out the Building Drivers guide. Configuration Files Appium now supports configuration files in addition to command-line arguments. In a nutshell, nearly all arguments which Appium 1.x required to be provided on the CLI are now able to be expressed via a configuration file. Configuration files may be in JSON, JS, or YAML format. See the Config Guide for a full explanation. Special Notes for Cloud Providers The rest of this document has applied to Appium generally, but some of the architectural changes in Appium 2.0 will constitute breaking changes for Appium-related service providers, whether a cloud-based Appium host or an internal service. At the end of the day, the maintainer of the Appium server is responsible for installing and making available the various Appium drivers and plugins that end users may wish to use. We encourage cloud providers to thoroughly read and understand our recommendation for cloud provider capabilities in order to support user needs in an industry-compatible way!","title":"Migrating from Appium 1.x to Appium 2.x"},{"location":"guides/migrating-1-to-2/#overview-of-appium-20","text":"Appium 2.0 is the most major new release of Appium in over 5 years. The changes in Appium 2.0 are not primarily related to changes in automation behaviors for specific platforms. Instead, Appium 2.0 reenvisions Appium as a platform where \"drivers\" (code projects that introduce support for automation of a given platform) and \"plugins\" (code projects that allow for overriding, altering, extending, or adding behaviors to Appium) can be easily created and shared. At the same time, the Appium project is taking the opportunity to remove many old and deprecated bits of functionality. Together these do introduce a few breaking changes to how Appium is installed, how drivers and various features are managed, and protocol support. These are detailed below.","title":"Overview of Appium 2.0"},{"location":"guides/migrating-1-to-2/#breaking-changes","text":"Have a look at the Appium 2.0 release notes for the most comprehensive lists of changes. Here we call out the breaking changes and what you need to do do account for them.","title":"Breaking Changes"},{"location":"guides/migrating-1-to-2/#installing-drivers-during-setup","text":"When you installed Appium 1.x, all available drivers would be installed at the same time as the main Appium server. This is no longer the case. Simply installing Appium 2.0 (e.g., by npm install -g appium ), will install the Appium server only, but no drivers. To install drivers, you must instead use the new Appium extension CLI . For example, to install the latest versions of the XCUITest and UiAutomator2 drivers, after installing Appium you would run the following commands: appium driver install xcuitest appium driver install uiautomator2 At this point, your drivers are installed and ready. There's a lot more you can do with this CLI so be sure to check out the docs on it. If you're running in a CI environment or want to install Appium along with some drivers all in one step, you can do so using some special flags during install, for example: npm install --global appium --drivers=xcuitest,uiautomator2 This will install Appium and the two drivers for you in one go.","title":"Installing drivers during setup"},{"location":"guides/migrating-1-to-2/#chromedriver-installation-flags","text":"In Appium 1.x it was possible to customize the way Chromedriver was installed (as part of the UiAutomator2 driver for example), using the following command line flags: --chromedriver-skip-install --chromedriver-version --chromedriver-cdnurl Because Appium 2.0 now installs drivers for you, and because these flags were implemented as NPM config flags, they will no longer work. Instead, use the following environment variables during driver installation: APPIUM_SKIP_CHROMEDRIVER_INSTALL CHROMEDRIVER_VERSION CHROMEDRIVER_CDNURL For example: APPIUM_SKIP_CHROMEDRIVER_INSTALL=1 appium driver install uiautomator2","title":"Chromedriver installation flags"},{"location":"guides/migrating-1-to-2/#driver-specific-command-line-options","text":"With Appium 1.x, command-line options specific to particular drivers were all hosted on the main Appium server. So, for example, --chromedriver-executable was a CLI parameter you could use with Appium to set the location of a specific Chromedriver version for use with, say, the UiAutomator2 driver. With Appium 2.x, all driver- and platform-specific CLI params have been moved to the drivers themselves. To access them, you'll now need to prepend the argument with the extension type (either driver or plugin ) and the name of the extension. For example, --chromedriver-executable becomes --driver-uiautomator2-chromedriver-executable .","title":"Driver-specific command line options"},{"location":"guides/migrating-1-to-2/#driver-specific-automation-commands","text":"The definition of certain commands that pertain only to specific drivers has been moved to those drivers' implementations. For example, pressKeyCode is specific to the UiAutomator2 driver and is now understood only by that driver. In practice, the only breaking change here is the kind of error you would encounter if the appropriate driver is not installed. Previously, you would get a 501 Not Yet Implemented error if using a driver that didn't implement the command. Now, you will get a 404 Not Found error because if a driver that doesn't know about the command is not active, the main Appium server will not define the route corresponding to the command.","title":"Driver-specific automation commands"},{"location":"guides/migrating-1-to-2/#driver-updates","text":"In the past, to get updates to your iOS or Android drivers, you'd simply wait for those updates to be rolled into a new release of Appium, and then update your Appium version. With Appium 2.x, the Appium server and the Appium drivers are versioned and released separately. This means that drivers can be on their own release cadence and that you can get driver updates as they happen, rather than waiting for a new Appium server release. The way to check for driver updates is with the CLI: appium driver list --updates If any updates are available, you can then run the update command for any given driver: appium driver update xcuitest (For a complete description of the update command, check out the Extension CLI doc) To update the Appium server itself, you do the same thing as in the past: npm install -g appium . Now, installing new versions of the Appium server will leave your drivers intact, so the whole process will be much more quick.","title":"Driver updates"},{"location":"guides/migrating-1-to-2/#protocol-changes","text":"Appium's API is based on the W3C WebDriver Protocol , and it has supported this protocol for years. Before the W3C WebDriver Protocol was designed as a web standard, several other protocols were used for both Selenium and Appium. These protocols were the \"JSONWP\" (JSON Wire Protocol) and \"MJSONWP\" (Mobile JSON Wire Protocol). The W3C Protocol differs from the (M)JSONWP protocols in a few small ways. Up until Appium 2.0, Appium supported both protocols, so that older Selenium/Appium clients could still communicate with newer Appium servers. Moving forward, support for older protocols will be removed.","title":"Protocol changes"},{"location":"guides/migrating-1-to-2/#capabilities","text":"One significant difference between old and new protocols is in the format of capabilities. Previously called \"desired capabilities\", and now called simply \"capabilities\", there is now a requirement for a so-called \"vendor prefix\" on any non-standard capabilities. The list of standard capabilities is given in the WebDriver Protocol spec , and includes a few commonly used capabilities such as browserName and platformName . These standard capabilities continue to be used as-is. All other capabilities must include a \"vendor prefix\" in their name. A vendor prefix is a string followed by a colon, such as appium: . Most of Appium's capabilities go beyond the standard W3C capabilities and must therefore include vendor prefixes (we recommend that you use appium: unless directed otherwise by documentation). For example: appium:app appium:noReset appium:deviceName This requirement may or may not be a breaking change for your test suites when targeting Appium 2.0. If you're using an updated Appium client, the client will add the appium: prefix for you on all necessary capabilities. New versions of the Appium Inspector tool will also do this. Cloud-based Appium providers may also do this. So simply be aware that if you get any messages to the effect that your capabilities lack a vendor prefix, this is how you solve that problem. On a related note, it will no longer be possible to start Appium sessions using WebDriver clients that don't support the W3C protocol (see below for a comment to this effect for the WD library). To make everyone's lives a bit easier, we've also introduced the option of wrapping up all Appium-related capabilities into one object capability, appium:options . You can bundle together anything that you would normally put an appium: prefix on into this one capability. Here's an example (in raw JSON) of how you might start an iOS session on the Safari browser using appium:options : { \"platformName\" : \"iOS\" , \"browserName\" : \"Safari\" , \"appium:options\" : { \"platformVersion\" : \"14.4\" , \"deviceName\" : \"iPhone 11\" , \"automationName\" : \"XCUITest\" } } (Of course, each client will have a different way of creating structured capabilities like appium:options or other ones that you might have seen such as goog:chromeOptions ). NB: capabilities that show up in appium:options will overwrite capabilities of the same name that show up at the top level of the object. For more information on capabilities, have a look at the Capabilities Guide .","title":"Capabilities"},{"location":"guides/migrating-1-to-2/#removed-commands","text":"In addition to commands which have been moved to driver implementations, commands which were a part of the old JSON Wire Protocol and not a part of the W3C Protocol are no longer available: TODO (these commands are being identified and removed and will be updated here when complete) If you use a modern Appium or Selenium client, you should no longer have access to these anyway, so any breaking changes should appear on the client side first and foremost.","title":"Removed Commands"},{"location":"guides/migrating-1-to-2/#image-analysis-features-moved-to-plugin","text":"One of the design goals for Appium 2.0 is to migrate non-core features into special extensions called plugins . This allows people to opt into features which require extra time to download or extra system setup. The various image-related features of Appium (image comparison, finding elements by image, etc...) have been moved into an officially supported plugin called images . If you use these image-related methods, to continue accessing them you will need to do two things. Install the plugin: appium plugin install images Ensure you start the Appium server with access to run the plugin by including it in the list of plugins designated on the command line, e.g., appium --use-plugins=images Image-related commands will also be removed on the client side of things, which means you will need to follow the instructions on the plugin README for installing client-side plugins to access these features.","title":"Image analysis features moved to plugin"},{"location":"guides/migrating-1-to-2/#execute-driver-script-command-moved-to-plugin","text":"If you use the advanced Execute Driver Script feature (which allows you to send in a WebdriverIO script to have it executed completely on the server instead of command-by-command from the client), this functionality has been moved to a plugin. Here's what to do to keep using it: Install the plugin: appium plugin install execute-driver Ensure you start the Appium server with access to run the plugin by including it in the list of plugins designated on the command line, e.g., appium --use-plugins=execute-driver","title":"Execute Driver Script command moved to plugin"},{"location":"guides/migrating-1-to-2/#external-files-no-longer-supported-for-nodeconfig-default-capabilities-allow-insecure-and-deny-insecure","text":"These options can be provided as strings on the command line (a JSON string for --nodeconfig and a comma-separated list of strings for --allow-insecure and --deny-insecure ). Arguments provided on the command line will likely need to be quoted or escaped. The recommended method to provide these options is now via a configuration file . In summary, if you are using a JSON Appium config file, you can simply cut-and-paste the contents of your \"nodeconfig\" JSON file into the value of the server.nodeconfig property. Any CSV-like files you had previously provided for --allow-insecure and --deny-insecure become the values of the server.allow-insecure and server.deny-insecure properties in the Appium config files (respectively); both are arrays of strings.","title":"External Files No Longer Supported for --nodeconfig, --default-capabilities, --allow-insecure and --deny-insecure"},{"location":"guides/migrating-1-to-2/#old-drivers-removed","text":"The old iOS and Android (UiAutomator 1) drivers and related tools (e.g., authorize-ios ) have been removed. They haven't been relevant for many years anyway.","title":"Old drivers removed"},{"location":"guides/migrating-1-to-2/#internal-packages-renamed","text":"Some Appium-internal NPM packages have been renamed (for example, appium-base-driver is now @appium/base-driver ). This is not a breaking change for Appium users, only for people who have built software that directly incorporates Appium's code.","title":"Internal packages renamed"},{"location":"guides/migrating-1-to-2/#wd-javascript-client-library-no-longer-supported","text":"For many years, some of Appium's authors maintained the WD client library. This library has been deprecated and has not been updated for use with the W3C WebDriver protocol. As such, if you're using this library you'll need to move to a more modern one. We recommend WebdriverIO .","title":"\"WD\" JavaScript client library no longer supported"},{"location":"guides/migrating-1-to-2/#appium-inspector-split-out-from-appium-desktop","text":"The inspecting portion of Appium Desktop has been moved to its own app, Appium Inspector: github.com/appium/appium-inspector . It's fully compatible with Appium 2.0 servers. Simply download it and run it on its own. You no longer need the GUI Appium Desktop server to inspect apps. The Appium Desktop server will continue to be supported at its original site: github.com/appium/appium-desktop . It will simply no longer bundle the Inspector with it. You can also now use the Appium Inspector without downloading anything, by visiting the web version of Appium Inspector . Note that to test against local servers, you'll need to start the server with --allow-cors so that the browser-based version of Appium Inspector can access your Appium server to start sessions.","title":"Appium Inspector split out from Appium Desktop"},{"location":"guides/migrating-1-to-2/#major-new-features","text":"Apart from the breaking changes mentioned above, in this section is a list of some of the major new features you may wish to take advantage of with Appium 2.0.","title":"Major New Features"},{"location":"guides/migrating-1-to-2/#plugins","text":"","title":"Plugins"},{"location":"guides/migrating-1-to-2/#server-plugins","text":"Appium extension authors can now develop their own server plugins, which can intercept and modify any Appium command, or even adjust the way the underlying Appium HTTP server itself works. To learn more about plugins, read the new Appium Introduction . Interested in building a plugin? Check out the Building Plugins guide.","title":"Server Plugins"},{"location":"guides/migrating-1-to-2/#client-plugins","text":"TODO","title":"Client Plugins"},{"location":"guides/migrating-1-to-2/#install-drivers-and-plugins-from-anywhere","text":"You're no longer limited to the drivers that come with Appium, or that the Appium team even knows about! Appium extension authors can now develop custom drivers, which can be downloaded or installed via Appium's Extension CLI from NPM, Git, GitHub, or even the local filesystem. Interested in building a driver? Check out the Building Drivers guide.","title":"Install drivers and plugins from anywhere"},{"location":"guides/migrating-1-to-2/#configuration-files","text":"Appium now supports configuration files in addition to command-line arguments. In a nutshell, nearly all arguments which Appium 1.x required to be provided on the CLI are now able to be expressed via a configuration file. Configuration files may be in JSON, JS, or YAML format. See the Config Guide for a full explanation.","title":"Configuration Files"},{"location":"guides/migrating-1-to-2/#special-notes-for-cloud-providers","text":"The rest of this document has applied to Appium generally, but some of the architectural changes in Appium 2.0 will constitute breaking changes for Appium-related service providers, whether a cloud-based Appium host or an internal service. At the end of the day, the maintainer of the Appium server is responsible for installing and making available the various Appium drivers and plugins that end users may wish to use. We encourage cloud providers to thoroughly read and understand our recommendation for cloud provider capabilities in order to support user needs in an industry-compatible way!","title":"Special Notes for Cloud Providers"},{"location":"guides/security/","text":"TODO","title":"Appium Server Security"},{"location":"guides/settings/","text":"TODO","title":"The Settings API"},{"location":"intro/","text":"As mentioned on the main page, Appium is an open-source project and ecosystem of related software, designed to facilitate UI automation of many app platforms. With the release of Appium 2.0, Appium has the following primary goals: 1 Make platform-specific automation capabilities available under a cross-platform, standard API Allow easy access to this API from any programming language Provide tools to enable convenient community development of Appium extensions So, take any app platform you know about, like iOS or Android. Appium wants for there to be a way for developers and testers to write UI automation code for that platform, according to a single, unified API. Based on Appium's goals, we have a lot of questions to answer to make it all work: Which API should that \"single, unified\" API be? How do we map that API to automation behaviour for a specific platform? How do we make that API accessible via multiple popular programming languages? There's another, larger, question lurking in the background here too, given that there are more app platforms out there than just iOS and Android: How do we enable automation for all the platforms? Exploring Appium's answers to these questions may not be the quickest way to learn what Appium is, but it is certainly a good one! So let's dive in. Appium's choice of API Appium is very fortunate to have been preceded by a technology which has been a long-standing pioneer in the field of UI automation, namely Selenium . The goal of the Selenium project has been to support UI automation of web browsers, and in this way we can think of it as occupying a subset of Appium's goals. Along the way, Selenium (and, after they merged, another project called WebDriver) developed a relatively stable API for browser automation. Over the years, Selenium worked with various web browser vendors and the W3C standards group to turn its API into an official web browser standard, called the WebDriver specification . All the main browsers now implement automation capabilities inline with the WebDriver spec, without the Selenium team having to maintain any software that performs actual automation; standards for the win! Appium's initial goals were to develop an automation standard for mobile apps (iOS and Android). We could have made up something new, but in the spirit of joining forces and keeping standards, well, standard, we decided to adopt the WebDriver spec as Appium's API. 2 While user interaction on websites and in mobile native apps are not entirely identical (with even greater differences once we start to consider, for example, TV platforms controlled by simple remotes), the fact is that most software UIs are pretty much the same. This means that the WebDriver spec provides automation API primitives (finding elements, interacting with elements, loading pages or screens, etc...) that more or less map to any platform. Of course, Appium wants to support the cases where user interaction does differ from web to mobile or web to TV, and so Appium also makes use of the built-in extensibility of the WebDriver spec. The result is that, no matter what platform you want to automate, when you use Appium, you will do so using the standard WebDriver spec, with two caveats: We might not have any way to support a particular WebDriver API command on a given platform, and so some commands might be unsupported (for example, getting or setting cookies is not possible in the world of native mobile app automation). We might support automation behaviours that go beyond what's available in the WebDriver API command list, though any such commands will be valid and spec-compliant extensions to the WebDriver API. How do you actually use the WebDriver API, particularly in the context of Appium? We'll cover that in the section below on how Appium provides universal programming language access. All you need to know for now is that the way Appium introduces a universal UI automation interface is by implementing the WebDriver protocol. Platform automation behaviour The next question is, how does Appium map this protocol to automation behaviour on a wide range of platforms? The trick is that, strictly speaking, Appium doesn't! It leaves this responsibility up to a kind of software module called an Appium driver . There's a whole Driver Introduction which you can read next, so we won't go into huge detail on how they work for now. What's important to understand at the moment is that a driver is kind of like a pluggable module for Appium that gives Appium the power to automate a particular platform (or set of platforms, depending on the goal of the driver). At the end of the day, a driver's responsibility is to simply implement an Appium-internal interface representing the WebDriver protocol. How it implements this interface is totally up to the driver, based on its strategy for making automation happen on a specific platform. Typically, and with a lot more complexity and difficulty in the details, a driver does this by relying on platform-specific automation technologies. For example, Apple maintains an iOS automation technology called XCUITest . The Appium driver that supports iOS app automation is called the XCUITest Driver because ultimately what it does is convert the WebDriver protocol to XCUITest library calls. One of the reasons that drivers are independent, pluggable modules is that they work completely differently from one another. The tools and requirements for building and using drivers for different platforms are completely different. And so Appium lets you use just the drivers that you need for your automation tasks. Choosing drivers and installing them so that you can use them with your Appium instance is so important that Appium has its very own CLI for managing drivers . So, to answer our original question, the way that Appium provides access to automation capabilities for a given platform is that the Appium team (or anyone else 3 ) writes a driver for that platform, implementing as much or little of the WebDriver protocol as desired. The driver can then be installed by anyone using Appium. Universal programming language access But what does it mean, or look like, to use Appium, anyway? Since Appium is ultimately a Node.js program, it could have looked like importing Appium and its drivers as libraries into your own Node.js programs. But that wouldn't meet Appium's goal of providing automation capabilities to people using any popular programming language. Luckily, the fact that Appium rode in on Selenium's coattails meant that we had a solution to this problem from day one. You see, the WebDriver specification is actually an HTTP-based protocol, meaning it is designed to be used over a network rather than within the memory of a single program. One of the main benefits of this \"client-server\" architecture is that it allows the automation implementer (the thing doing the automation, in this case the 'server') to be completely distinct from the automation runner (the thing defining what automation should be done, in what steps, etc..., in this case the 'client'). Basically, all the \"hard stuff\" (actually figuring out how to make automation happen on a given platform) can be handled in one place by the server, and \"thin\" client libraries can be written in any programming language which simply encode HTTP requests to the server in language-appropriate way. It's possible, in other words, to bring basic Appium / WebDriver capabilities to a new programming language relatively easily, assuming high-level HTTP libraries exist, simply by coding up a basic HTTP client in that language. There are a couple important takeaways here for you, the Appium user: Appium is an HTTP server . It must run as a process on some computer for as long as you want to be able to use it for automation. It must be accessible on the network to whichever computer you want to use to run the automation from (whether that is the same machine or one across the world). Unless you want to write raw HTTP calls or use cURL, using Appium for automation involves the use of an Appium Client in the language of your choice. The goal of each of these clients is to encapsulate the WebDriver protocol so that rather than worrying about the protocol itself, you can work with objects and methods that feel idiomatic for your language. The Appium server and the Appium client do not need to be running on the same computer. You simply need to be able to send HTTP requests from the client to the server over some network. This greatly facilitates the use of cloud providers for Appium, since they can host the Appium server and any related drivers and devices, and all you need to do is point your client script to their secure endpoints. And of course, none of this is about \"testing\" per se, purely about the use of Appium and its client libraries for automation purposes. If you want to do automation for the purpose of \"testing\", you'll likely want to enlist the help of test runners, test frameworks, and the like, none of which need be related to Appium; one of the benefits of Appium's \"universal accessibility\" is that it plays well with whatever set of tools you find most beneficial for your situation. Appium's huge scope Appium's vision (automation of everything under a single API) is huge! Certainly, much bigger than the team of core maintainers for the open source project. So how does Appium hope to achieve this goal? Basically, by empowering the community to develop functionality on top of Appium as a platform . This is what we call the Appium \"ecosystem\". The Appium team does officially maintain a few drivers itself (for example, the XCUITest driver that we spoke about earlier). But it cannot hope to have the platform-specific expertise or the capacity to maintain drivers for many different platforms. But what we have done, particularly beginning with Appium 2.0, is to provide tools to empower the community to join in our vision: Anyone can create a driver simply by creating a Node.js module that conforms to the appropriate conventions and implements any (sub|super)set of the WebDriver protocol. Creating a driver often involves a minimal amount of code because the WebDriver protocol details are abstracted away, and many helper libraries are available---the same libraries that power the Appium team's own drivers. Sharing drivers with others is easy using the Appium driver CLI. There is no central authority. Anyone can share drivers publicly or privately, for free or for sale. Drivers can be open or closed source (though obviously we appreciate open source!). Appium's vision of being a platform for development extends beyond the support of automation for all app platforms. As a popular automation tool, there are many opportunities for integrating Appium with all kinds of other tools and services. In addition, there are many feature ideas for Appium, either as a core server or in its incarnation across various drivers, which the core team will never have time to build. And so, with Appium 2.0, Appium has released a plugin system that enables anyone to build and share modules that change how Appium works! In the same way that drivers are easily shareable and consumable via the Appium driver CLI, plugins can be published and consumed via a parallel Plugin CLI . Plugins can do all sorts of things, for example adding the ability for Appium to find and interact with screen regions based on a template image (as in the images plugin ). There are very few limitations on what you can do with plugins, so you might also be interested in learning how to Build Plugins in Node.js that can be used with Appium. So that's Appium: an extensible, universal interface for the UI automation of potentially everything! Read on into some of the specific intro docs for more details, or check out the various guides to dive into some more general concepts and features of Appium. To meet these primary goals, we also work with a set of secondary goals or methodology principles, which we also encourage for Appium extension developers: As far as possible, rely on (and contribute to) open source technology As far as possible, rely on vendor-provided tools for a given platform As far as possible, rely on automation tools that allow automation of unmodified apps (prefer not to require the user to build in additional SDKs or software that introduce discrepancies between the test version of the app and the production version) As far as possible, rely on existing standards instead of creating new ones \u21a9 Technically, when Appium was first written, we were dealing with something older than the WebDriver spec, called the JSON Wire Protocol. Since then, Appium continued to evolve along with the W3C spec and is fully W3C-compliant. \u21a9 You can build and share your own drivers! Check out Building Drivers to learn more about how to develop drivers in Node.js that can be used with Appium. \u21a9","title":"Overview of Appium"},{"location":"intro/#appiums-choice-of-api","text":"Appium is very fortunate to have been preceded by a technology which has been a long-standing pioneer in the field of UI automation, namely Selenium . The goal of the Selenium project has been to support UI automation of web browsers, and in this way we can think of it as occupying a subset of Appium's goals. Along the way, Selenium (and, after they merged, another project called WebDriver) developed a relatively stable API for browser automation. Over the years, Selenium worked with various web browser vendors and the W3C standards group to turn its API into an official web browser standard, called the WebDriver specification . All the main browsers now implement automation capabilities inline with the WebDriver spec, without the Selenium team having to maintain any software that performs actual automation; standards for the win! Appium's initial goals were to develop an automation standard for mobile apps (iOS and Android). We could have made up something new, but in the spirit of joining forces and keeping standards, well, standard, we decided to adopt the WebDriver spec as Appium's API. 2 While user interaction on websites and in mobile native apps are not entirely identical (with even greater differences once we start to consider, for example, TV platforms controlled by simple remotes), the fact is that most software UIs are pretty much the same. This means that the WebDriver spec provides automation API primitives (finding elements, interacting with elements, loading pages or screens, etc...) that more or less map to any platform. Of course, Appium wants to support the cases where user interaction does differ from web to mobile or web to TV, and so Appium also makes use of the built-in extensibility of the WebDriver spec. The result is that, no matter what platform you want to automate, when you use Appium, you will do so using the standard WebDriver spec, with two caveats: We might not have any way to support a particular WebDriver API command on a given platform, and so some commands might be unsupported (for example, getting or setting cookies is not possible in the world of native mobile app automation). We might support automation behaviours that go beyond what's available in the WebDriver API command list, though any such commands will be valid and spec-compliant extensions to the WebDriver API. How do you actually use the WebDriver API, particularly in the context of Appium? We'll cover that in the section below on how Appium provides universal programming language access. All you need to know for now is that the way Appium introduces a universal UI automation interface is by implementing the WebDriver protocol.","title":"Appium's choice of API"},{"location":"intro/#platform-automation-behaviour","text":"The next question is, how does Appium map this protocol to automation behaviour on a wide range of platforms? The trick is that, strictly speaking, Appium doesn't! It leaves this responsibility up to a kind of software module called an Appium driver . There's a whole Driver Introduction which you can read next, so we won't go into huge detail on how they work for now. What's important to understand at the moment is that a driver is kind of like a pluggable module for Appium that gives Appium the power to automate a particular platform (or set of platforms, depending on the goal of the driver). At the end of the day, a driver's responsibility is to simply implement an Appium-internal interface representing the WebDriver protocol. How it implements this interface is totally up to the driver, based on its strategy for making automation happen on a specific platform. Typically, and with a lot more complexity and difficulty in the details, a driver does this by relying on platform-specific automation technologies. For example, Apple maintains an iOS automation technology called XCUITest . The Appium driver that supports iOS app automation is called the XCUITest Driver because ultimately what it does is convert the WebDriver protocol to XCUITest library calls. One of the reasons that drivers are independent, pluggable modules is that they work completely differently from one another. The tools and requirements for building and using drivers for different platforms are completely different. And so Appium lets you use just the drivers that you need for your automation tasks. Choosing drivers and installing them so that you can use them with your Appium instance is so important that Appium has its very own CLI for managing drivers . So, to answer our original question, the way that Appium provides access to automation capabilities for a given platform is that the Appium team (or anyone else 3 ) writes a driver for that platform, implementing as much or little of the WebDriver protocol as desired. The driver can then be installed by anyone using Appium.","title":"Platform automation behaviour"},{"location":"intro/#universal-programming-language-access","text":"But what does it mean, or look like, to use Appium, anyway? Since Appium is ultimately a Node.js program, it could have looked like importing Appium and its drivers as libraries into your own Node.js programs. But that wouldn't meet Appium's goal of providing automation capabilities to people using any popular programming language. Luckily, the fact that Appium rode in on Selenium's coattails meant that we had a solution to this problem from day one. You see, the WebDriver specification is actually an HTTP-based protocol, meaning it is designed to be used over a network rather than within the memory of a single program. One of the main benefits of this \"client-server\" architecture is that it allows the automation implementer (the thing doing the automation, in this case the 'server') to be completely distinct from the automation runner (the thing defining what automation should be done, in what steps, etc..., in this case the 'client'). Basically, all the \"hard stuff\" (actually figuring out how to make automation happen on a given platform) can be handled in one place by the server, and \"thin\" client libraries can be written in any programming language which simply encode HTTP requests to the server in language-appropriate way. It's possible, in other words, to bring basic Appium / WebDriver capabilities to a new programming language relatively easily, assuming high-level HTTP libraries exist, simply by coding up a basic HTTP client in that language. There are a couple important takeaways here for you, the Appium user: Appium is an HTTP server . It must run as a process on some computer for as long as you want to be able to use it for automation. It must be accessible on the network to whichever computer you want to use to run the automation from (whether that is the same machine or one across the world). Unless you want to write raw HTTP calls or use cURL, using Appium for automation involves the use of an Appium Client in the language of your choice. The goal of each of these clients is to encapsulate the WebDriver protocol so that rather than worrying about the protocol itself, you can work with objects and methods that feel idiomatic for your language. The Appium server and the Appium client do not need to be running on the same computer. You simply need to be able to send HTTP requests from the client to the server over some network. This greatly facilitates the use of cloud providers for Appium, since they can host the Appium server and any related drivers and devices, and all you need to do is point your client script to their secure endpoints. And of course, none of this is about \"testing\" per se, purely about the use of Appium and its client libraries for automation purposes. If you want to do automation for the purpose of \"testing\", you'll likely want to enlist the help of test runners, test frameworks, and the like, none of which need be related to Appium; one of the benefits of Appium's \"universal accessibility\" is that it plays well with whatever set of tools you find most beneficial for your situation.","title":"Universal programming language access"},{"location":"intro/#appiums-huge-scope","text":"Appium's vision (automation of everything under a single API) is huge! Certainly, much bigger than the team of core maintainers for the open source project. So how does Appium hope to achieve this goal? Basically, by empowering the community to develop functionality on top of Appium as a platform . This is what we call the Appium \"ecosystem\". The Appium team does officially maintain a few drivers itself (for example, the XCUITest driver that we spoke about earlier). But it cannot hope to have the platform-specific expertise or the capacity to maintain drivers for many different platforms. But what we have done, particularly beginning with Appium 2.0, is to provide tools to empower the community to join in our vision: Anyone can create a driver simply by creating a Node.js module that conforms to the appropriate conventions and implements any (sub|super)set of the WebDriver protocol. Creating a driver often involves a minimal amount of code because the WebDriver protocol details are abstracted away, and many helper libraries are available---the same libraries that power the Appium team's own drivers. Sharing drivers with others is easy using the Appium driver CLI. There is no central authority. Anyone can share drivers publicly or privately, for free or for sale. Drivers can be open or closed source (though obviously we appreciate open source!). Appium's vision of being a platform for development extends beyond the support of automation for all app platforms. As a popular automation tool, there are many opportunities for integrating Appium with all kinds of other tools and services. In addition, there are many feature ideas for Appium, either as a core server or in its incarnation across various drivers, which the core team will never have time to build. And so, with Appium 2.0, Appium has released a plugin system that enables anyone to build and share modules that change how Appium works! In the same way that drivers are easily shareable and consumable via the Appium driver CLI, plugins can be published and consumed via a parallel Plugin CLI . Plugins can do all sorts of things, for example adding the ability for Appium to find and interact with screen regions based on a template image (as in the images plugin ). There are very few limitations on what you can do with plugins, so you might also be interested in learning how to Build Plugins in Node.js that can be used with Appium. So that's Appium: an extensible, universal interface for the UI automation of potentially everything! Read on into some of the specific intro docs for more details, or check out the various guides to dive into some more general concepts and features of Appium. To meet these primary goals, we also work with a set of secondary goals or methodology principles, which we also encourage for Appium extension developers: As far as possible, rely on (and contribute to) open source technology As far as possible, rely on vendor-provided tools for a given platform As far as possible, rely on automation tools that allow automation of unmodified apps (prefer not to require the user to build in additional SDKs or software that introduce discrepancies between the test version of the app and the production version) As far as possible, rely on existing standards instead of creating new ones \u21a9 Technically, when Appium was first written, we were dealing with something older than the WebDriver spec, called the JSON Wire Protocol. Since then, Appium continued to evolve along with the W3C spec and is fully W3C-compliant. \u21a9 You can build and share your own drivers! Check out Building Drivers to learn more about how to develop drivers in Node.js that can be used with Appium. \u21a9","title":"Appium's huge scope"},{"location":"intro/clients/","text":"For all the reasons discussed in the main intro , Appium is based on the W3C WebDriver specification . This means that Appium implements a client-server architecture. The server (consisting of Appium itself along with any drivers or plugins you are using for automation) is connected to the devices under test, and is actually responsible for making automation happen on those devices. The client (driven by you , the Appium test author) is responsible for sending commands to the server over the network, and receiving responses from the server as a result. These responses can be used to tell whether automation commands are successful, or might contain information that you queried about the state of the application. This document is a conceptual introduction to the client side of this equation. Info For more about the server side of the equation (i.e., how does Appium actually control devices?), check out our Intro to Appium Drivers . To skip to a list of links to Appium client libraries, check out the Ecosystem documentation. What sorts of automation commands are available? That is up to the particular driver and plugins that you are using in any given session. A standard set of commands would include, for example, the following: Find Element Click Element Get Page Source Take Screenshot If you look at these commands in the WebDriver specification, you'll notice that they are not defined in terms of any particular programming language. They are not Java commands, or JavaScript commands, or Python commands. Instead, they form part of an HTTP API which can be accessed from within any programming language (or none! you could just use cURL if you want). So, for example, the Find Element command corresponds to an HTTP POST request sent to the HTTP endpoint /session/:sessionid/element (where in this case, :sessionid is a placeholder for the unique session ID generated by the server in a previous call to Create Session ). This information is primarily useful for people developing technology that works with the WebDriver spec. It's not particularly useful for people trying to write Appium or Selenium tests. When you write an Appium test, you want to use a programming language you're familiar with. Luckily, there exist a set of Appium client libraries 1 that take care of the responsibility of speaking HTTP to the Appium server. Instead, they expose a set of \"native\" commands for a particular programming language, so that, to the test author, it just feels like you're writing Python, or JavaScript, or Java. As an example, here's the same simple set of Appium commands in four different programming languages, using the recommended Appium client binding for each language (note that this is not working sample code including all appropriate imports; see each client library's instructions for setup and command reference): JavaScript (Webdriver.io) Java Python Ruby const element = await driver . $ ( '//*[@text=\"Foo\"]' ); await element . click (); console . log ( await element . getText ()) console . log ( await driver . getPageSource ()) WebElement element = driver . findElement ( By . Xpath ( \"//*[@text='Foo']\" )) element . click () System . out . println ( element . getText ()) System . out . println ( driver . getPageSource ()) element = driver . find_element ( by = By . XPATH , value = '//*[@text=\"Foo\"]' ) element . click () print ( element . text ) print ( driver . page_source ) element = driver . find_element :xpath , '//*[@text=\"Foo\"]' element . click puts element . text puts driver . page_source Each of these scripts, despite being in different languages, does the same thing under the hood: Call Find Element with a using parameter of xpath and a value parameter expressing the XPath query used to find an element. (If you're confused about these terms, you might find an introduction to Appium or Selenium useful) Call Click Element with the ID of the element found in the previous call. Call Get Element Text with the ID of the same element, and print it to the console. Call Get Page Source to retrieve the page/app source and print it to the console. The only other thing to keep in mind before choosing or using a client is that each client is independently maintained. Just because a feature is available in one client, it doesn't mean it's available in another client (though all clients support at least the standard W3C protocol plus any common appium extensions). Just because one client has a nice set of helper functions, doesn't mean another will. Some clients are kept very frequently up to date, and others are not! So when thinking about choosing a library, the first consideration is the language you want to use, and the second consideration is how full-featured and well-maintained the library is! To learn how to use an Appium client, visit that client's homepage to learn more. In many cases, the Appium client for a given language is built on top of the Selenium client for that language, and so certain Appium clients may only document the features which the Appium client added on top of the Selenium client. All that to say, for a full reference, you may need to visit both the Appium client documentation as well as the Selenium client documentation. That's all you need to know about Appium clients! Head over to the Ecosystem page to check out the current list of clients. These libraries are alternately called \"clients\", \"client libraries\", or \"client bindings\". They all mean the same thing! \u21a9","title":"Intro to Appium Clients"},{"location":"intro/drivers/","text":"As the main Overview makes clear, \"drivers\" are basically Appium's answer to the question, \"how do we support automation of multiple, unrelated platforms?\" In this doc we'll get into a little more detail about how drivers work. The specific details of how drivers work probably don't matter too much for you, unless you're planning on writing your own driver or contributing to an existing driver (things we hope you do!). The main benefit in understanding a bit more of how drivers work is that being aware of the typical complexity or the typical driver architecture will inform your debugging process when you inevitably run into an issue in one of your tests. Interface Implementations At the most basic level, drivers are simply Node.js classes that extend a special class included in Appium, called BaseDriver . You could have something very close to a \"working\" driver, with these very simple lines of code: import BaseDriver from '@appium/base-driver' class MyNewDriver extends BaseDriver { } This empty driver doesn't do anything, but you could wrap it up in a Node.js module, add a few Appium-related fields to the module's manifest ( package.json ), and then install it using appium driver install . So, from a technical perspective, an Appium driver is just a bit of code that inherits from some other Appium code. That's it! Now, inheriting from BaseDriver actually gives us a lot, because BaseDriver is essentially an encapsulation of the entire WebDriver protocol. So all a driver needs to do to do something useful is to implement Node.js methods with names corresponding to their WebDriver protocol equivalents. So let's say I wanted to do something with this empty driver; first I have to decide which WebDriver command I want to implement. For our example, let's take the Navigate To WebDriver command. Leave aside for the moment what I want to have the driver do when this command is executed. To tell Appium the driver can handle the command, all we have to do is define a method like this in our driver class: 1 async setUrl ( url ) { // do whatever we want here } That's it! How we actually implement the command is totally up to us, and depends on the platform(s) we want to support. Here are some different example implementations of this command for different platforms: Browsers: execute some JavaScript to set window.location.href iOS apps: launch an app using a deep link Android apps: launch an app using a deep link React apps: load a specific route Unity: go to a named scene So you can see there can be a lot of differences between how drivers implement the same WebDriver command across platforms. 2 What is the same , though, is how they express that they can handle a protocol command. We're going into this great amount of detail (which you don't need to remember, by the way), because it's important to stress the point that an Appium driver is not inherently anything in particular, other than a bit of JS code that can handle WebDriver protocol commands. Where you go from there is up to you, the driver author! Automation mapping But typically what driver authors want to do is to provide automation behaviours for a given platform(s) that are semantically very similar to the the WebDriver spec implementations for browsers. When you want to find an element, you should get a reference to a UI element. When you want to click or tap that element, the resulting behaviour should be the same as if a person were to click or tap on the element. And so on. So the real challenge for driver authors is not how to work with the WebDriver protocol (because BaseDriver encapsulates all that for you), but how to make the actual automation happen on the target platform. Every driver relies on its own set of underlying technologies here. As mentioned in the Overview , the iOS driver uses an Apple technology called XCUITest . These underlying automation technologies usually have proprietary or idiosyncratic APIs of their own. Writing a driver becomes the task of mapping the WebDriver protocol to this underlying API (or sometimes a set of different underlying APIs--for example, the UiAutomator2 driver relies not only on the UiAutomator2 technology from Google, but also functions only available through ADB , as well as functions only available via the Android SDK inside a helper app). Tying it all together into a single, usable, WebDriver interface is the incredibly useful (but incredibly challenging) art of driver development! Multi-level architecture In practice, this often results in a pretty complex architecture. Let's take iOS for example again. The XCUITest framework (the one used by the Appium driver) expects code that calls it to be written in Objective-C or Swift. Furthermore, XCUITest code can only be run in a special mode triggered by Xcode (and directly or indirectly, the Xcode command line tools). In other words, there's no straightforward way to go from a Node.js function implementation (like setUrl() above) to XCUITest API calls. What the XCUITest driver authors have done is instead to split the driver into two parts: one part written in Node.js (the part which is incorporated into Appium and which initially handles the WebDriver commands), and the other part written in Objective-C (the part which actually gets run on an iOS device and makes XCUITest API calls). This makes interfacing with XCUITest possible, but introduces the new problem of coordination between the two parts. The driver authors could have chosen any of a number of very different strategies to model the communication between the Node.js side and the Objective-C side, but at the end of the day decided to use ... the WebDriver protocol! That's right, the Objective-C side of the XCUITest driver is itself a WebDriver implementation, called WebDriverAgent . 3 The Appium XCUITest driver builds and manages WebDriverAgent for you, which can be a pain and involves the use of Xcode. The XCUITest driver does lots more than what can be done by WebDriverAgent, for example working with simulators or devices, installing apps, and the like. The moral of the story is that driver architectures can become quite complicated and multilayered, due to the nature of the problem we're trying to solve. It also means it can be difficult sometimes to tell where in this chain of technologies something has gone wrong, if you run into a problem with a particular test. With the XCUITest world again, we have something like the following set of technologies all in play at the same time: Your test code (in its programming language) - owned by you The Appium client library - owned by Appium The Selenium client library - owned by Selenium The network (local or Internet) The Appium server - owned by Appium The Appium XCUITest driver - owned by Appium WebDriverAgent - owned by Appium Xcode - owned by Apple XCUITest - owned by Apple iOS itself - owned by Apple macOS (where Xcode and iOS simulators run) - owned by Apple It's a pretty deep stack! Proxy mode There's one other important architectural aspect of drivers to understand. It can be exemplified again by the XCUITest driver. Recall that we just discussed how the two \"halves\" of the XCUITest driver both speak the WebDriver protocol---the Node.js half clicks right into Appium's WebDriver server, and the Objective-c half (WebDriverAgent) is its own WebDriver implementation. This opens up the possibility of Appium taking a shortcut in certain cases. Let's imagine that the XCUITest driver needs to implement the Click Element command. The internal code of this implementation would look something like taking the appropriate parameters and constructing an HTTP request to the WebDriverAgent server. In this case, we're basically just reconstructing the client's original call to the Appium server! 4 So there's really no need to even write a function implementing the Click Element command. Instead, the XCUITest driver can just let Appium know that this command should be proxied directly to some other WebDriver server. If you're not familiar with the concept of \"proxying,\" in this case it just means that the XCUITest driver will not be involved at all in handling the command. Instead it will merely be repackaged and forwarded to WebDriverAgent at the protocol level, and WebDriverAgent's response will likewise be passed back directly to the client, without any XCUITest driver code seeing it or modifying it. This architectural pattern provides a nice bonus for driver authors who choose to deal with the WebDriver protocol everywhere, rather than constructing bespoke protocols. It also means that Appium can create wrapper drivers for any other existing WebDriver implementation very easily. If you look at the Appium Safari driver code, for example, you'll see that it implements basically no standard commands, because all of these are proxied directly to an underlying SafariDriver process. It's important to understand that this proxying business is sometimes happening under the hood, because if you're ever diving into some open source driver code trying to figure out where a command is implemented, you might be surprised to find no implementation at all in the Node.js driver code itself! In that case, you'll need to figure out where commands are being proxied to so you can look there for the appropriate implementation. OK, that's enough for this very detailed introduction to drivers! You might notice that setUrl doesn't look anything like Navigate To , so how did we know to use it rather than some other random string? Well, Appium's WebDriver-protocol-to-method-name mapping is defined in a special file within the @appium/base-driver package called routes.js . So if you're writing a driver, this is where you would go to figure out what method names to use and what parameters to expect. Or you could look at the source for any of the main Appium drivers! \u21a9 Of course, we want to keep the semantics as similar as possible, but in the world of iOS, for example, launching an app via a deep link (a URL with a special app-specific scheme) is about as close as we are going to get to navigating to a web URL. \u21a9 You could in theory, therefore, point your WebDriver client straight to WebDriverAgent and bypass Appium entirely. This is usually not convenient, however, for a few reasons: \u21a9 It's not exactly the same call, because the Appium server and the WebDriverAgent server will generate different session IDs, but these differences will be handled transparently. \u21a9","title":"Intro to Appium Drivers"},{"location":"intro/drivers/#interface-implementations","text":"At the most basic level, drivers are simply Node.js classes that extend a special class included in Appium, called BaseDriver . You could have something very close to a \"working\" driver, with these very simple lines of code: import BaseDriver from '@appium/base-driver' class MyNewDriver extends BaseDriver { } This empty driver doesn't do anything, but you could wrap it up in a Node.js module, add a few Appium-related fields to the module's manifest ( package.json ), and then install it using appium driver install . So, from a technical perspective, an Appium driver is just a bit of code that inherits from some other Appium code. That's it! Now, inheriting from BaseDriver actually gives us a lot, because BaseDriver is essentially an encapsulation of the entire WebDriver protocol. So all a driver needs to do to do something useful is to implement Node.js methods with names corresponding to their WebDriver protocol equivalents. So let's say I wanted to do something with this empty driver; first I have to decide which WebDriver command I want to implement. For our example, let's take the Navigate To WebDriver command. Leave aside for the moment what I want to have the driver do when this command is executed. To tell Appium the driver can handle the command, all we have to do is define a method like this in our driver class: 1 async setUrl ( url ) { // do whatever we want here } That's it! How we actually implement the command is totally up to us, and depends on the platform(s) we want to support. Here are some different example implementations of this command for different platforms: Browsers: execute some JavaScript to set window.location.href iOS apps: launch an app using a deep link Android apps: launch an app using a deep link React apps: load a specific route Unity: go to a named scene So you can see there can be a lot of differences between how drivers implement the same WebDriver command across platforms. 2 What is the same , though, is how they express that they can handle a protocol command. We're going into this great amount of detail (which you don't need to remember, by the way), because it's important to stress the point that an Appium driver is not inherently anything in particular, other than a bit of JS code that can handle WebDriver protocol commands. Where you go from there is up to you, the driver author!","title":"Interface Implementations"},{"location":"intro/drivers/#automation-mapping","text":"But typically what driver authors want to do is to provide automation behaviours for a given platform(s) that are semantically very similar to the the WebDriver spec implementations for browsers. When you want to find an element, you should get a reference to a UI element. When you want to click or tap that element, the resulting behaviour should be the same as if a person were to click or tap on the element. And so on. So the real challenge for driver authors is not how to work with the WebDriver protocol (because BaseDriver encapsulates all that for you), but how to make the actual automation happen on the target platform. Every driver relies on its own set of underlying technologies here. As mentioned in the Overview , the iOS driver uses an Apple technology called XCUITest . These underlying automation technologies usually have proprietary or idiosyncratic APIs of their own. Writing a driver becomes the task of mapping the WebDriver protocol to this underlying API (or sometimes a set of different underlying APIs--for example, the UiAutomator2 driver relies not only on the UiAutomator2 technology from Google, but also functions only available through ADB , as well as functions only available via the Android SDK inside a helper app). Tying it all together into a single, usable, WebDriver interface is the incredibly useful (but incredibly challenging) art of driver development!","title":"Automation mapping"},{"location":"intro/drivers/#multi-level-architecture","text":"In practice, this often results in a pretty complex architecture. Let's take iOS for example again. The XCUITest framework (the one used by the Appium driver) expects code that calls it to be written in Objective-C or Swift. Furthermore, XCUITest code can only be run in a special mode triggered by Xcode (and directly or indirectly, the Xcode command line tools). In other words, there's no straightforward way to go from a Node.js function implementation (like setUrl() above) to XCUITest API calls. What the XCUITest driver authors have done is instead to split the driver into two parts: one part written in Node.js (the part which is incorporated into Appium and which initially handles the WebDriver commands), and the other part written in Objective-C (the part which actually gets run on an iOS device and makes XCUITest API calls). This makes interfacing with XCUITest possible, but introduces the new problem of coordination between the two parts. The driver authors could have chosen any of a number of very different strategies to model the communication between the Node.js side and the Objective-C side, but at the end of the day decided to use ... the WebDriver protocol! That's right, the Objective-C side of the XCUITest driver is itself a WebDriver implementation, called WebDriverAgent . 3 The Appium XCUITest driver builds and manages WebDriverAgent for you, which can be a pain and involves the use of Xcode. The XCUITest driver does lots more than what can be done by WebDriverAgent, for example working with simulators or devices, installing apps, and the like. The moral of the story is that driver architectures can become quite complicated and multilayered, due to the nature of the problem we're trying to solve. It also means it can be difficult sometimes to tell where in this chain of technologies something has gone wrong, if you run into a problem with a particular test. With the XCUITest world again, we have something like the following set of technologies all in play at the same time: Your test code (in its programming language) - owned by you The Appium client library - owned by Appium The Selenium client library - owned by Selenium The network (local or Internet) The Appium server - owned by Appium The Appium XCUITest driver - owned by Appium WebDriverAgent - owned by Appium Xcode - owned by Apple XCUITest - owned by Apple iOS itself - owned by Apple macOS (where Xcode and iOS simulators run) - owned by Apple It's a pretty deep stack!","title":"Multi-level architecture"},{"location":"intro/drivers/#proxy-mode","text":"There's one other important architectural aspect of drivers to understand. It can be exemplified again by the XCUITest driver. Recall that we just discussed how the two \"halves\" of the XCUITest driver both speak the WebDriver protocol---the Node.js half clicks right into Appium's WebDriver server, and the Objective-c half (WebDriverAgent) is its own WebDriver implementation. This opens up the possibility of Appium taking a shortcut in certain cases. Let's imagine that the XCUITest driver needs to implement the Click Element command. The internal code of this implementation would look something like taking the appropriate parameters and constructing an HTTP request to the WebDriverAgent server. In this case, we're basically just reconstructing the client's original call to the Appium server! 4 So there's really no need to even write a function implementing the Click Element command. Instead, the XCUITest driver can just let Appium know that this command should be proxied directly to some other WebDriver server. If you're not familiar with the concept of \"proxying,\" in this case it just means that the XCUITest driver will not be involved at all in handling the command. Instead it will merely be repackaged and forwarded to WebDriverAgent at the protocol level, and WebDriverAgent's response will likewise be passed back directly to the client, without any XCUITest driver code seeing it or modifying it. This architectural pattern provides a nice bonus for driver authors who choose to deal with the WebDriver protocol everywhere, rather than constructing bespoke protocols. It also means that Appium can create wrapper drivers for any other existing WebDriver implementation very easily. If you look at the Appium Safari driver code, for example, you'll see that it implements basically no standard commands, because all of these are proxied directly to an underlying SafariDriver process. It's important to understand that this proxying business is sometimes happening under the hood, because if you're ever diving into some open source driver code trying to figure out where a command is implemented, you might be surprised to find no implementation at all in the Node.js driver code itself! In that case, you'll need to figure out where commands are being proxied to so you can look there for the appropriate implementation. OK, that's enough for this very detailed introduction to drivers! You might notice that setUrl doesn't look anything like Navigate To , so how did we know to use it rather than some other random string? Well, Appium's WebDriver-protocol-to-method-name mapping is defined in a special file within the @appium/base-driver package called routes.js . So if you're writing a driver, this is where you would go to figure out what method names to use and what parameters to expect. Or you could look at the source for any of the main Appium drivers! \u21a9 Of course, we want to keep the semantics as similar as possible, but in the world of iOS, for example, launching an app via a deep link (a URL with a special app-specific scheme) is about as close as we are going to get to navigating to a web URL. \u21a9 You could in theory, therefore, point your WebDriver client straight to WebDriverAgent and bypass Appium entirely. This is usually not convenient, however, for a few reasons: \u21a9 It's not exactly the same call, because the Appium server and the WebDriverAgent server will generate different session IDs, but these differences will be handled transparently. \u21a9","title":"Proxy mode"},{"location":"intro/history/","text":"Appium has been around in one form or another since 2012. It's been under the direction of various individuals and organizations, and it's even been implemented in 3 different programming languages! Welcome to more than you ever wanted to know about how Appium got to be what is it today... Early Inspiration Dan Cuellar was the Test Manager at Zoosk in 2011, when he encountered a problem. The length of the test passes on the iOS product was getting out of hand. Less testing was an option, but would come with additional risk, especially with it taking several days to get patches through the iOS App Store Review process. He thought back to his days working on websites and realized automation was the answer. Dan surveyed the existing landscape of tools, only to find that all of them hand major drawbacks. The tool supplied by Apple, UIAutomation, required tests to be written in JavaScript, and did not allow for real-time debugging or interpretation. It also had to be executed inside the Xcode profiling tool, Instruments. Other 3rd-party tools used private APIs and required SDKs and HTTP Servers to be embedded into the application. This seemed highly undesirable. Unsatisfied with the existing options, Dan asked his manager for some additional time to see if he could find a better way. He spent 2 weeks poking and prodding around to see if there was a way to use approved Apple technologies to automate an iOS application. The first implementation he tried used AppleScript to send messages to Mac UI elements using the OS X accessibility APIs. This worked to some degree, but would never work on real devices, not to mention other drawbacks. So he thought, what if I could get the UIAutomation framework to run in real time like an interpreter? He looked into it and he determined that all he would need to do is find a way to receive, execute, and reply to commands from within a UIAutomation javascript program. Using the utility Apple provided for executing shell commands he was able to cat sequentially ordered text files to receive commands, eval() the output to execute them, and write them back to disk with python . He then prepared code in C# that implemented the Selenium-style syntax to write the sequentially ordered javascript commands. iOSAuto is born. Selenium Conference 2012 Dan was selected to speak at Selenium Conference 2012 in London about an entirely different topic. As part of his presentation, he showed off iOS Automation using Selenium syntax to demonstrate writing platform-agnostic tests that use separate platform-specific page objects with a common interface. To his surprise, the cool test architecture would take a backseat to the spectacle of iOS tests running like WebDriver tests. Several people suggested that he give a lightning talk later in the conference to explain exactly how it worked. On the second day of the conference, Dan stepped up on stage to give the lightning talk. Jason Huggins, co-creator of Selenium, moderated the lightning talks. Dan experienced technical difficulties getting his presentation to load, and Jason nearly had to move on to the next lightning talk. At the last moment, the screen turned on and Dan jumped into his presentation. He explained the details of his implementation and how it worked, begged for contributors, and in five minutes it was over. The crowd applauded politely, and he left the stage. The Phone Rings Four months after the Selenium Conference, Jason called Dan. Jason had been working on iOS testing support for a client at Sauce Labs. Jason remembered Dan's lightning talk and thought the project might be useful to Jason's work, but Dan's source code was not public. Jason asked Dan to meet up. Later that week, Dan met Jason in a bar in San Francisco and showed him the source code for iOS Auto. A long-time open source advocate, Jason encouraged Dan to release his code under an open source license. In August, Dan released the source code on GitHub in C#. Jason encouraged Dan to change the language to make the project more appealing to potential contributors. Dan uploaded a new version in Python . In September, Jason added a web server and began to implement the WebDriver wire protocol over HTTP, making iOS Auto scriptable from any Selenium WebDriver client library in any language. The Mobile Testing Summit Jason decided that the project should be presented at the Mobile Testing Summit in November, but suggested that the project get a new name first. Many ideas were thrown out and they settled on AppleCart. A day later, while he was perusing some of Apple's guidance on copyright and trademarks, Jason noticed that under the section of examples for names Apple would defend its trademarks against, the first example was \"AppleCart\". He called Dan and informed him of the situation, and they brainstormed for a bit before Jason hit the jackpot. Appium... Selenium for Apps. Sauce Labs and Node.js In January 2013, not long after the Mobile Testing Summit, Sauce Labs decided to fully back Appium and provide more developer power. A task force was created to evaluate the current state and how best to move forward with the project. The team, which included Jonathan Lipps (the current project lead), decided that Appium needed a rebirth, and ultimately settled on Node.js as the framework to use. Node is well-known as a fast and efficient web server backend, and at the end of the day, Appium is just a highly-specialized web server. It was also decided that JavaScript as a language was accessible enough that Appium would be able to grow into a larger community of open-source developers with JavaScript than the other options on the table. In just a few days, the team leveraged the existing work on Appium and had a new version of Appium with as much functionality as the previous Python version. The foundation had been laid for Appium's basic architecture, and we have been successfully building on it since. A few weeks into this sprint, Jonathan Lipps was formally designated project lead and he began to strategize how to get more people from the community involved with Appium's development. Appium Around the World Ultimately, Jonathan decided that getting Appium in front of as many developers at conferences and meetups was the best way to attract users and contributions. Appium in its new incarnation was debuted at the Google Test Automation Conference 2013 . Later in 2013, Appium was presented at conferences and meetups all around the US, as well as in England, Poland, Portugal, and Australia. Notably, Jonathan had Appium perform as instruments in a band and Dan Cuellar put together a fun Appium video montage for Selenium Conference. But during all these presentations and conferences, the project continued to develop. Early in 2013 we released Android and Selendroid support, making Appium the first truly cross-platform automation framework. The project also continued to attract users and contributors, and by the end of 2013, we'd already had well over 1,000 commits. The Road to Appium 1.0 Appium began to grow and mature significantly. In May 2014, we released Appium 1.0, which stood as a milestone in Appium's development. Appium was given various awards and became the most popular open-source cross-platform mobile automation framework. Stability improved, bugs were prioritized and fixed, and features added. Sauce Labs increased the number of developers it donated to working on Appium, but the entire community stayed involved in guiding the project and contributing to it, and project governance continued to happen in the open, on public mailing lists and GitHub's issue tracker. The Appium Umbrella Broadens Eventually, it became clear that the Appium codebase was not optimized for a large team of distributed, sometime contributors. We took the opportunity as a committer team to rewrite Appium from the ground up, using a more modern version of the JavaScript language, and redoing Appium's architecture so that it was easy for users or third-party developers to build their own Appium \"drivers\". We wanted for it to be easier for new contributors to get ramped up on the Appium codebase, and to see support for new platforms added to Appium by groups other than the core team. That vision has begun to be fulfilled, with groups like Microsoft and Youi.tv adding drivers to Appium for Windows desktop app automation and Youi.tv app automation, respectively. Who knows what platforms will be added next? Appium To The People In late 2016, Sauce Labs donated Appium as a project to the JS Foundation , in order to cement for the world Sauce's commitment that Appium remains open source. The JS Foundation is a non-profit open source stewardship organization which takes responsibility for holding the copyright for open source projects, as well as ensuring they have a long and successful tenure in the community. As a result of our move to a non-profit foundation, we hope that the door will open even more widely for new contributors, either as individuals or representing one of the many companies which now have an interest in seeing Appium move forward. Eventually, the JS Foundation merged into the OpenJS Foundation , and Appium is currently an Impact Project in the foundation. Appium 2.0 Appium 2.0 was released in 2022, with a new focus on Appium as an ecosystem rather than a singular project. Drivers and plugins can be developed and shared by anyone, opening up a world of possibilities for automation-related development for platforms far beyond iOS and Android.","title":"Appium Project History"},{"location":"intro/history/#early-inspiration","text":"Dan Cuellar was the Test Manager at Zoosk in 2011, when he encountered a problem. The length of the test passes on the iOS product was getting out of hand. Less testing was an option, but would come with additional risk, especially with it taking several days to get patches through the iOS App Store Review process. He thought back to his days working on websites and realized automation was the answer. Dan surveyed the existing landscape of tools, only to find that all of them hand major drawbacks. The tool supplied by Apple, UIAutomation, required tests to be written in JavaScript, and did not allow for real-time debugging or interpretation. It also had to be executed inside the Xcode profiling tool, Instruments. Other 3rd-party tools used private APIs and required SDKs and HTTP Servers to be embedded into the application. This seemed highly undesirable. Unsatisfied with the existing options, Dan asked his manager for some additional time to see if he could find a better way. He spent 2 weeks poking and prodding around to see if there was a way to use approved Apple technologies to automate an iOS application. The first implementation he tried used AppleScript to send messages to Mac UI elements using the OS X accessibility APIs. This worked to some degree, but would never work on real devices, not to mention other drawbacks. So he thought, what if I could get the UIAutomation framework to run in real time like an interpreter? He looked into it and he determined that all he would need to do is find a way to receive, execute, and reply to commands from within a UIAutomation javascript program. Using the utility Apple provided for executing shell commands he was able to cat sequentially ordered text files to receive commands, eval() the output to execute them, and write them back to disk with python . He then prepared code in C# that implemented the Selenium-style syntax to write the sequentially ordered javascript commands. iOSAuto is born.","title":"Early Inspiration"},{"location":"intro/history/#selenium-conference-2012","text":"Dan was selected to speak at Selenium Conference 2012 in London about an entirely different topic. As part of his presentation, he showed off iOS Automation using Selenium syntax to demonstrate writing platform-agnostic tests that use separate platform-specific page objects with a common interface. To his surprise, the cool test architecture would take a backseat to the spectacle of iOS tests running like WebDriver tests. Several people suggested that he give a lightning talk later in the conference to explain exactly how it worked. On the second day of the conference, Dan stepped up on stage to give the lightning talk. Jason Huggins, co-creator of Selenium, moderated the lightning talks. Dan experienced technical difficulties getting his presentation to load, and Jason nearly had to move on to the next lightning talk. At the last moment, the screen turned on and Dan jumped into his presentation. He explained the details of his implementation and how it worked, begged for contributors, and in five minutes it was over. The crowd applauded politely, and he left the stage.","title":"Selenium Conference 2012"},{"location":"intro/history/#the-phone-rings","text":"Four months after the Selenium Conference, Jason called Dan. Jason had been working on iOS testing support for a client at Sauce Labs. Jason remembered Dan's lightning talk and thought the project might be useful to Jason's work, but Dan's source code was not public. Jason asked Dan to meet up. Later that week, Dan met Jason in a bar in San Francisco and showed him the source code for iOS Auto. A long-time open source advocate, Jason encouraged Dan to release his code under an open source license. In August, Dan released the source code on GitHub in C#. Jason encouraged Dan to change the language to make the project more appealing to potential contributors. Dan uploaded a new version in Python . In September, Jason added a web server and began to implement the WebDriver wire protocol over HTTP, making iOS Auto scriptable from any Selenium WebDriver client library in any language.","title":"The Phone Rings"},{"location":"intro/history/#the-mobile-testing-summit","text":"Jason decided that the project should be presented at the Mobile Testing Summit in November, but suggested that the project get a new name first. Many ideas were thrown out and they settled on AppleCart. A day later, while he was perusing some of Apple's guidance on copyright and trademarks, Jason noticed that under the section of examples for names Apple would defend its trademarks against, the first example was \"AppleCart\". He called Dan and informed him of the situation, and they brainstormed for a bit before Jason hit the jackpot. Appium... Selenium for Apps.","title":"The Mobile Testing Summit"},{"location":"intro/history/#sauce-labs-and-nodejs","text":"In January 2013, not long after the Mobile Testing Summit, Sauce Labs decided to fully back Appium and provide more developer power. A task force was created to evaluate the current state and how best to move forward with the project. The team, which included Jonathan Lipps (the current project lead), decided that Appium needed a rebirth, and ultimately settled on Node.js as the framework to use. Node is well-known as a fast and efficient web server backend, and at the end of the day, Appium is just a highly-specialized web server. It was also decided that JavaScript as a language was accessible enough that Appium would be able to grow into a larger community of open-source developers with JavaScript than the other options on the table. In just a few days, the team leveraged the existing work on Appium and had a new version of Appium with as much functionality as the previous Python version. The foundation had been laid for Appium's basic architecture, and we have been successfully building on it since. A few weeks into this sprint, Jonathan Lipps was formally designated project lead and he began to strategize how to get more people from the community involved with Appium's development.","title":"Sauce Labs and Node.js"},{"location":"intro/history/#appium-around-the-world","text":"Ultimately, Jonathan decided that getting Appium in front of as many developers at conferences and meetups was the best way to attract users and contributions. Appium in its new incarnation was debuted at the Google Test Automation Conference 2013 . Later in 2013, Appium was presented at conferences and meetups all around the US, as well as in England, Poland, Portugal, and Australia. Notably, Jonathan had Appium perform as instruments in a band and Dan Cuellar put together a fun Appium video montage for Selenium Conference. But during all these presentations and conferences, the project continued to develop. Early in 2013 we released Android and Selendroid support, making Appium the first truly cross-platform automation framework. The project also continued to attract users and contributors, and by the end of 2013, we'd already had well over 1,000 commits.","title":"Appium Around the World"},{"location":"intro/history/#the-road-to-appium-10","text":"Appium began to grow and mature significantly. In May 2014, we released Appium 1.0, which stood as a milestone in Appium's development. Appium was given various awards and became the most popular open-source cross-platform mobile automation framework. Stability improved, bugs were prioritized and fixed, and features added. Sauce Labs increased the number of developers it donated to working on Appium, but the entire community stayed involved in guiding the project and contributing to it, and project governance continued to happen in the open, on public mailing lists and GitHub's issue tracker.","title":"The Road to Appium 1.0"},{"location":"intro/history/#the-appium-umbrella-broadens","text":"Eventually, it became clear that the Appium codebase was not optimized for a large team of distributed, sometime contributors. We took the opportunity as a committer team to rewrite Appium from the ground up, using a more modern version of the JavaScript language, and redoing Appium's architecture so that it was easy for users or third-party developers to build their own Appium \"drivers\". We wanted for it to be easier for new contributors to get ramped up on the Appium codebase, and to see support for new platforms added to Appium by groups other than the core team. That vision has begun to be fulfilled, with groups like Microsoft and Youi.tv adding drivers to Appium for Windows desktop app automation and Youi.tv app automation, respectively. Who knows what platforms will be added next?","title":"The Appium Umbrella Broadens"},{"location":"intro/history/#appium-to-the-people","text":"In late 2016, Sauce Labs donated Appium as a project to the JS Foundation , in order to cement for the world Sauce's commitment that Appium remains open source. The JS Foundation is a non-profit open source stewardship organization which takes responsibility for holding the copyright for open source projects, as well as ensuring they have a long and successful tenure in the community. As a result of our move to a non-profit foundation, we hope that the door will open even more widely for new contributors, either as individuals or representing one of the many companies which now have an interest in seeing Appium move forward. Eventually, the JS Foundation merged into the OpenJS Foundation , and Appium is currently an Impact Project in the foundation.","title":"Appium To The People"},{"location":"intro/history/#appium-20","text":"Appium 2.0 was released in 2022, with a new focus on Appium as an ecosystem rather than a singular project. Drivers and plugins can be developed and shared by anyone, opening up a world of possibilities for automation-related development for platforms far beyond iOS and Android.","title":"Appium 2.0"},{"location":"intro/requirements/","text":"The basic requirements for the Appium server are: A macOS, Linux, or Windows operating system Node.js version >= 14 NPM version >= 8 (NPM is usually bundled with Node.js, but can be upgraded independently) By itself, Appium is relatively lightweight and doesn't have significant disk space or RAM requirements. It can even be run in resource-constrained environments like Raspberry Pi, so long as Node.js is available. To use Appium to automate a particular platform, please refer to the documentation of the Appium driver(s) for that platform for additional dependencies. It is almost universally the case that Appium drivers for a given platform will require the developer toolchain and SDKs for that platform to be available.","title":"Appium Requirements"},{"location":"quickstart/","text":"Let's get up and running with Appium! To successfully use this quickstart, it's recommended that you first have read the Introduction , so that you understand the concepts involved in running Appium and writing Appium scripts. The basic plan for this quickstart is as follows: Install Appium Install an Appium driver and its dependencies (we'll be using the UiAutomator2 driver for these examples) Install an Appium client library in your language or choice (this guide contains options for JavaScript, Python, and Java, though Appium clients also exist in other language). Write and run a simple Appium automation script using a sample application Requirements Before getting started, make sure your system satisfies the requirements for running the Appium server. Additional requirements will be discussed in conjunction with installing the UiAutomator2 driver. The guide also assumes you're basic command line proficiency on your platform, for example being able to run commands, set and persist environment variables, etc... Now you're ready to get started! So head on over to Installing Appium .","title":"Quickstart Intro"},{"location":"quickstart/#requirements","text":"Before getting started, make sure your system satisfies the requirements for running the Appium server. Additional requirements will be discussed in conjunction with installing the UiAutomator2 driver. The guide also assumes you're basic command line proficiency on your platform, for example being able to run commands, set and persist environment variables, etc... Now you're ready to get started! So head on over to Installing Appium .","title":"Requirements"},{"location":"quickstart/install/","text":"Installing Appium is as easy as running a single NPM command: npm i -g appium@next Note Currently, you must use appium@next instead of just appium . Once Appium 2.0 has been officially published, you can simply use appium . This command installs Appium globally on your system so that you can access it from the command line simply by running the appium command. Go ahead and run it now: appium You should see some output that starts with a line like this: [Appium] Welcome to Appium v2.0.0 That's it! If you get this kind of output, the Appium server is up and running. Go ahead and quit it (CTRL-C) and move on to the next step, where we'll install a driver for automating Android apps.","title":"Install Appium"},{"location":"quickstart/next-steps/","text":"Now that you've successfully set up your system for Android automation and run a simple test, you'll want to continue exploring this documentation. In particular, these are good guides and reference materials especially for beginners: Managing Appium Drivers and Plugins Capabilities The list of available Drivers and Plugins You'll also find that the Appium Inspector is an indispensable tool for use in Appium test-writing, as it enables visual inspection of apps and helps you to discover element locators for use in your test scripts. You might also take advantage of one of the many online Appium courses available to you. Good luck and have fun!","title":"Next Steps"},{"location":"quickstart/test-java/","text":"TODO","title":"Write a Test (Java)"},{"location":"quickstart/test-js/","text":"To write an Appium test in JavaScript (Node.js), we need to choose an Appium-compatible client library. The best-maintained library and the one the Appium team recommends using is WebdriverIO , so let's use that. Since we already have Appium installed we know our Node and NPM requirements are already satisfied. So just create a new project directory somewhere on your computer and then initialize a new Node.js project in it: npm init It doesn't really matter what you put in the prompts, just so long as you end up with a valid package.json . Now, install the webdriverio package via NPM: npm i --save-dev webdriverio Once this is done, your package.json file should include a section like the following: package.json { \"devDependencies\" : { \"webdriverio\" : \"^7.19.3\" } } Now it's time to type up the test itself. Create a new file called test.js with the following contents: test.js const { remote } = require ( 'webdriverio' ); const capabilities = { platformName : 'Android' , 'appium:automationName' : 'UiAutomator2' , 'appium:deviceName' : 'Android' , 'appium:appPackage' : 'com.android.settings' , 'appium:appActivity' : '.Settings' , }; const wdOpts = { host : process . env . APPIUM_HOST || 'localhost' , port : parseInt ( process . env . APPIUM_PORT , 10 ) || 4723 , logLevel : 'info' , capabilities , }; async function runTest () { const driver = await remote ( wdOpts ); try { const batteryItem = await driver . $ ( '//*[@text=\"Battery\"]' ); await batteryItem . click (); } finally { await driver . pause ( 1000 ); await driver . deleteSession (); } } runTest (). catch ( console . error ); Note It's not within the scope of this guide to give a complete run-down on the WebdriverIO client library or everything that's happening here, so we'll leave the code itself unexplained in detail for now. You may want to read up particularly on Appium Capabilities in addition to familiarizing yourself with the excellent WebdriverIO documentation for a fuller explanation of the various API commands you see and what their purpose is. Basically, this code is doing the following: Defining a set of \"Capabilities\" (parameters) to send to the Appium server so Appium knows what kind of thing you want to automate. Starting an Appium session on the built-in Android settings app. Finding the \"Battery\" list item and clicking it. Pausing for a moment purely for visual effect. Ending the Appium session. That's it! Let's give it a try. Before you run the test, make sure that you have an Appium server running in another terminal session, otherwise you'll get an error about not being able to connect to one. Then, you can execute the script: node test.js If all goes well, you'll see the Settings app open up and navigate to the \"Battery\" view before the app closes again. Congratulations, you've started your Appium journey! Read on for some next steps to explore.","title":"Write a Test (JS)"},{"location":"quickstart/test-py/","text":"The Appium Python Client is an official Appium client in Python, which is available via pypi under the Appium-Python-Client package name. It inherits from the Selenium Python Binding , so installing the Appium Python Client includes the selenium binding. pip install Appium-Python-Client This example uses Python's built-in unittest module, though you can use any Python test framework you want. The Appium Python client adds the appium: vendor prefix automatically. You usually do not need to worry about the prefix. test.py import unittest from appium import webdriver from appium.webdriver.common.appiumby import AppiumBy capabilities = dict ( platformName = 'Android' , automationName = 'uiautomator2' , deviceName = 'Android' , appPackage = 'com.android.settings' , appActivity = '.Settings' , language = 'en' , locale = 'US' ) appium_server_url = 'http://localhost:4723' class TestAppium ( unittest . TestCase ): def setUp ( self ) -> None : self . driver = webdriver . Remote ( appium_server_url , capabilities ) def tearDown ( self ) -> None : if self . driver : self . driver . quit () def test_find_battery ( self ) -> None : el = self . driver . find_element ( by = AppiumBy . XPATH , value = '//*[@text=\"Battery\"]' ) el . click () if __name__ == '__main__' : unittest . main () Note It's not within the scope of this guide to give a complete run-down on the Python client library or everything that's happening here, so we'll leave the code itself unexplained in detail for now. - You may want to read up particularly on Appium Capabilities . - functional test code in Python Client GitHub repository should help to find more working example. - Documentation also helps to find methods defined in the Appium Python Client. Basically, this code is doing the following: Defining a set of \"Capabilities\" (parameters) to send to the Appium server so Appium knows what kind of thing you want to automate. Starting an Appium session on the built-in Android settings app. Finding the \"Battery\" list item and clicking it. Pausing for a moment purely for visual effect. Ending the Appium session. That's it! Let's give it a try. Before you run the test, make sure that you have an Appium server running in another terminal session, otherwise you'll get an error about not being able to connect to one. Then, you can execute the script: python test.py If all goes well, you'll see the Settings app open up and navigate to the \"Battery\" view before the app closes again. Congratulations, you've started your Appium journey! Read on for some next steps to explore.","title":"Write a Test (Python)"},{"location":"quickstart/test-rb/","text":"The AppiumLib and the AppiumLibCore are Appium officcial client libraries in Ruby, which are available via gem under the appium_lib and the appium_lib_core package names. The appium_lib_core inherits from the Selenium Ruby Binding, and the appium_lib inherits from the appium_lib_core, so intalling these libraries include the selenium binding. gem install appium_lib # or gem install appium_lib_core The appium_lib_core is the main part as an Appium client. appium_lib has various helper methods, but the driver instance was ordinally designed to be used as a global variable. It could causes an issue to handle the instance. appium_lib_core does not have such a global variable. This example is by the appium_lib_core with test-unit gem module. Tes code in appium_lib should be similar. test.py require 'appium_lib_core' require 'test/unit' CAPABILITIES = { platformName : 'Android' , automationName : 'uiautomator2' , deviceName : 'Android' , appPackage : 'com.android.settings' , appActivity : '.Settings' , language : 'en' , locale : 'US' } SERVER_URL = 'http://localhost:4723' class AppiumTest < Test :: Unit :: TestCase def setup @core = :: Appium :: Core . for capabilities : CAPABILITIES @driver = @core . start_driver server_url : SERVER_URL end def teardown @driver &. quit end def test_version @driver . wait { | d | d . find_element : xpath , '//*[@text=\"Battery\"]' } . click end end Note It's not within the scope of this guide to give a complete run-down on the Ruby client library or everything that's happening here, so we'll leave the code itself unexplained in detail for now. You may want to read up particularly on Appium Capabilities . functional test code in the appium_lib_core GitHub repository should help to find more working example. Documentation appium_lib_core and appium_lib also helps to find avvailable methods. Basically, this code is doing the following: Defining a set of \"Capabilities\" (parameters) to send to the Appium server so Appium knows what kind of thing you want to automate. Starting an Appium session on the built-in Android settings app. Finding the \"Battery\" list item and clicking it. Pausing for a moment purely for visual effect. Ending the Appium session. That's it! Let's give it a try. Before you run the test, make sure that you have an Appium server running in another terminal session, otherwise you'll get an error about not being able to connect to one. Then, you can execute the script: bundle install bundle exec ruby test.rb If all goes well, you'll see the Settings app open up and navigate to the \"Battery\" view before the app closes again. Congratulations, you've started your Appium journey! Read on for some next steps to explore.","title":"Write a Test (Ruby)"},{"location":"quickstart/uiauto2-driver/","text":"You can't do much with Appium unless you have a driver , which is an interface that allows Appium to automate a particular platform. Info For this quickstart guide, we're going to be automating an app on the Android platform, because the system requirements for Android automation via Appium are the same as for Appium itself (whereas the iOS driver, for example, requires you to be using macOS). The driver we're going to use is called the UiAutomator2 Driver . It's worth visiting that driver's documentation and bookmarking it, because it will be an invaluable reference down the line. Set up Android automation requirements According to the driver, in addition to a working Appium server, we also need to do the following: Download Android SDK platform tools . You will probably want to download Android Studio and manage the SDK tools from within it for the easiest experience. Set an environment variable pointing to the directory on disk where the Android tools are installed. You can usually find the path to this directory in the Android Studio SDK manager. It will contain the platform-tools and other directories. We need to define and persist the environment variable as ANDROID_HOME (or alternatively ANDROID_SDK_ROOT ). Use the Android SDK manager to download whichever Android platform we want to automate (for example, API level 30) Install the Java JDK (for the most recent Android API levels, JDK 9 is required, otherwise JDK 8 is required). It's easiest to use the OpenJDK packages . Make sure you get the JDK and not the JRE. When the JDK is installed, you'll need to find the path to the JDK home directory as it was installed on your system. This will be the directory that contains the bin , include , and other directories. The path must be persisted as an environment variable named JAVA_HOME , so that Appium can find the appropriate Java tooling that is required to work with the Android platform. Use Android Studio to create and launch an Android Virtual Device (an AVD, otherwise known as an emulator). You may need to download the system images for the API level of the emulator you want to create. Using the AVD creation wizard in Android Studio is generally the easiest way to do all of this. Note You can also use a physical Android device, so long as it is configured for debugging and development With the emulator or device connected, you can run adb devices (via the binary located at $ANDROID_HOME/platform-tools/adb ) to verify that your device shows up as connected. Once your device shows up as connected in ADB, and you've verified that the environment variables are set up correctly in the terminal context where you are going to run Appium, you should be good to go! If you ran into problems with any of these steps, refer to the driver documentation, or the various Android or Java documentation sites as necessary. Also, congratulations: whether or not you intended to, you now have the Android developer toolchain set up on your system, so you can get busy making Android apps if you want! Install the driver itself Since the UiAutomator2 driver is maintained by the core Appium team, it has an 'official' driver name that you can use to install it easily via the Appium Extension CLI : appium driver install uiautomator2 It should produce output that looks something like: Attempting to find and install driver 'uiautomator2' \u2714 Installing 'uiautomator2' using NPM install spec 'appium-uiautomator2-driver' Driver uiautomator2@2.0.5 successfully installed - automationName: UiAutomator2 - platformNames: [\"Android\"] Running this command will locate and install the latest version of the UiAutomator2 driver, making it available for automation. Note that when it is installed it tells you what platforms it is valid for (in this case, Android ), and what automation name (the appium:automationName capability ) must be used to select this driver for use during an Appium session (in this case, UiAutomator2 ). Note In this quickstart we have used the Extension CLI to install the UiAutomator2 driver, but if you are incorporating Appium into a Node.js project, you might prefer to use NPM to manage Appium and its connected drivers. To learn more about this technique, visit the guide on managing Appium extensions . Now, start the Appium server again (run appium ), and you should see that the newly-installed driver is listed as available: [Appium] Available drivers: [Appium] - uiautomator2@2.0.5 (automationName 'UiAutomator2') With the Android setup complete and the UiAutomator2 driver installed, you're ready to write your first test! So pick the language you're most comfortable with under the quickstart menu and give it a shot.","title":"Install the UiAutomator2 Driver"},{"location":"quickstart/uiauto2-driver/#set-up-android-automation-requirements","text":"According to the driver, in addition to a working Appium server, we also need to do the following: Download Android SDK platform tools . You will probably want to download Android Studio and manage the SDK tools from within it for the easiest experience. Set an environment variable pointing to the directory on disk where the Android tools are installed. You can usually find the path to this directory in the Android Studio SDK manager. It will contain the platform-tools and other directories. We need to define and persist the environment variable as ANDROID_HOME (or alternatively ANDROID_SDK_ROOT ). Use the Android SDK manager to download whichever Android platform we want to automate (for example, API level 30) Install the Java JDK (for the most recent Android API levels, JDK 9 is required, otherwise JDK 8 is required). It's easiest to use the OpenJDK packages . Make sure you get the JDK and not the JRE. When the JDK is installed, you'll need to find the path to the JDK home directory as it was installed on your system. This will be the directory that contains the bin , include , and other directories. The path must be persisted as an environment variable named JAVA_HOME , so that Appium can find the appropriate Java tooling that is required to work with the Android platform. Use Android Studio to create and launch an Android Virtual Device (an AVD, otherwise known as an emulator). You may need to download the system images for the API level of the emulator you want to create. Using the AVD creation wizard in Android Studio is generally the easiest way to do all of this. Note You can also use a physical Android device, so long as it is configured for debugging and development With the emulator or device connected, you can run adb devices (via the binary located at $ANDROID_HOME/platform-tools/adb ) to verify that your device shows up as connected. Once your device shows up as connected in ADB, and you've verified that the environment variables are set up correctly in the terminal context where you are going to run Appium, you should be good to go! If you ran into problems with any of these steps, refer to the driver documentation, or the various Android or Java documentation sites as necessary. Also, congratulations: whether or not you intended to, you now have the Android developer toolchain set up on your system, so you can get busy making Android apps if you want!","title":"Set up Android automation requirements"},{"location":"quickstart/uiauto2-driver/#install-the-driver-itself","text":"Since the UiAutomator2 driver is maintained by the core Appium team, it has an 'official' driver name that you can use to install it easily via the Appium Extension CLI : appium driver install uiautomator2 It should produce output that looks something like: Attempting to find and install driver 'uiautomator2' \u2714 Installing 'uiautomator2' using NPM install spec 'appium-uiautomator2-driver' Driver uiautomator2@2.0.5 successfully installed - automationName: UiAutomator2 - platformNames: [\"Android\"] Running this command will locate and install the latest version of the UiAutomator2 driver, making it available for automation. Note that when it is installed it tells you what platforms it is valid for (in this case, Android ), and what automation name (the appium:automationName capability ) must be used to select this driver for use during an Appium session (in this case, UiAutomator2 ). Note In this quickstart we have used the Extension CLI to install the UiAutomator2 driver, but if you are incorporating Appium into a Node.js project, you might prefer to use NPM to manage Appium and its connected drivers. To learn more about this technique, visit the guide on managing Appium extensions . Now, start the Appium server again (run appium ), and you should see that the newly-installed driver is listed as available: [Appium] Available drivers: [Appium] - uiautomator2@2.0.5 (automationName 'UiAutomator2') With the Android setup complete and the UiAutomator2 driver installed, you're ready to write your first test! So pick the language you're most comfortable with under the quickstart menu and give it a shot.","title":"Install the driver itself"}]}