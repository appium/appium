diff --git a/packages/base-driver/lib/basedriver/core.ts b/packages/base-driver/lib/basedriver/core.ts
index ecfd85b25..aaa29ff42 100644
--- a/packages/base-driver/lib/basedriver/core.ts
+++ b/packages/base-driver/lib/basedriver/core.ts
@@ -23,6 +23,7 @@ import {DEFAULT_BASE_PATH, PROTOCOLS} from '../constants';
 import {errors} from '../protocol';
 import DeviceSettings from './device-settings';
 import helpers, {BASEDRIVER_VER} from './helpers';
+import { executeShellWPromise, parseWDAUrl, getWDAStatus } from './mcloud-utils';
 
 const NEW_COMMAND_TIMEOUT_MS = 60 * 1000;
 
@@ -211,6 +212,59 @@ export class DriverCore<const C extends Constraints, Settings extends StringReco
     return {};
   }
 
+
+  async getStatusWDA (exitCode?: number | null) {
+    const wdaURL = await parseWDAUrl();
+    if (!wdaURL) {
+      throw new Error("Environment variable WDA_ENV is undefined");
+    }
+    const status = await getWDAStatus(wdaURL);
+    if (!status || 'success' != status.value.state) {
+      if (exitCode != null) {
+          this.log.error("Error for sending of WDA status http call. See appium logs for details")
+          this.log.warn(`[MCLOUD] Killing Appium instance with "exit(${exitCode})"`);
+          process.exit(exitCode);
+      }
+      throw new Error("Error for sending of WDA status http call. See appium logs for details");
+    }
+    return {"status": "success", "details": status};
+  }
+    
+  async getStatusADB(exitCode?: number | null) {
+    const deviceUDID = process.env.DEVICE_UDID;
+    if (deviceUDID) {
+      const adbDevicesCmd = 'adb devices | grep $DEVICE_UDID | grep "device"';
+      try {
+        await executeShellWPromise(adbDevicesCmd);
+        return {"status": "success", "details": `Connected device with UDID ${deviceUDID} is ready for execution`};
+      } catch (error) {
+        if (exitCode != null) {
+          this.log.error(`Connected device with UDID ${deviceUDID} is NOT ready for execution. Device was not returned by adb`)
+          this.log.warn(`[MCLOUD] Killing Appium instance with "exit(${exitCode})"`);
+          process.exit(exitCode);
+        }
+        throw new Error(`Connected device with UDID ${deviceUDID} is NOT ready for execution. Device was not returned by adb`);
+      }
+    } else {
+      const deviceName = process.env.ANDROID_DEVICES;
+      if(!deviceName) {
+        throw new Error(`Neither DEVICE_UDID nor ANDROID_DEVICES environment variables were found.`);
+      }
+      const adbDevicesCmd = 'adb devices | grep $ANDROID_DEVICES | grep "device"';
+      try {
+        await executeShellWPromise(adbDevicesCmd);
+        return {"status": "success", "details": `Connected device with name ${deviceName} is ready for execution`};
+      } catch (error) {
+        if (exitCode != null) {
+          this.log.error(`Connected device with UDID ${deviceUDID} is NOT ready for execution. Device was not returned by adb`)
+          this.log.warn(`[MCLOUD] Killing Appium instance with "exit(${exitCode})"`);
+          process.exit(exitCode);
+        }
+        throw new Error(`Connected device with name ${deviceUDID} is NOT ready for execution. Device was not returned by adb`);
+      }
+    }
+  }
+
   /**
    * method required by MJSONWP in order to determine whether it should
    * respond with an invalid session response
diff --git a/packages/base-driver/lib/basedriver/driver.ts b/packages/base-driver/lib/basedriver/driver.ts
index 09f547e79..0f2fe5414 100644
--- a/packages/base-driver/lib/basedriver/driver.ts
+++ b/packages/base-driver/lib/basedriver/driver.ts
@@ -312,6 +312,9 @@ export class BaseDriver<
 
     this.log.info(`Session created with session id: ${this.sessionId}`);
 
+    // save current sessionId globally to handle negative use-case instead of desired fallbackSessionId
+    process.env.sessionId = this.sessionId;
+
     return [this.sessionId, caps] as CreateResult;
   }
   async getSessions() {
diff --git a/packages/base-driver/lib/basedriver/helpers.js b/packages/base-driver/lib/basedriver/helpers.js
index 5f89176ba..48a431c0d 100644
--- a/packages/base-driver/lib/basedriver/helpers.js
+++ b/packages/base-driver/lib/basedriver/helpers.js
@@ -7,6 +7,9 @@ import { LRUCache } from 'lru-cache';
 import AsyncLock from 'async-lock';
 import axios from 'axios';
 import B from 'bluebird';
+import { getLocalAppsFolder, getSharedFolderForAppUrl, getLocalFileForAppUrl, getFileContentLength } from './mcloud-utils';
+// @ts-ignore
+import { stat } from 'fs';
 
 // for compat with running tests transpiled and in-place
 const {version: BASEDRIVER_VER} = fs.readPackageJsonFrom(__dirname);
@@ -31,6 +34,7 @@ const APPLICATIONS_CACHE = new LRUCache({
         `expired after ${CACHED_APPS_MAX_AGE}ms`
     );
     if (fullPath) {
+      logger.info(`[MCLOUD] APPLICATIONS_CACHE setting. Deleting files by path: ${fullPath}`);
       fs.rimraf(fullPath);
     }
   },
@@ -56,6 +60,7 @@ process.on('exit', () => {
   for (const appPath of appPaths) {
     try {
       // Asynchronous calls are not supported in onExit handler
+      logger.info(`[MCLOUD] process.on('exit'). Deleting files by path: ${appPath}`);
       fs.rimrafSync(appPath);
     } catch (e) {
       logger.warn(e.message);
@@ -131,6 +136,7 @@ async function configureApp(
   let newApp = app;
   let shouldUnzipApp = false;
   let packageHash = null;
+  let localAppsFolder;
   /** @type {import('axios').AxiosResponse['headers']|undefined} */
   let headers = undefined;
   /** @type {RemoteAppProps} */
@@ -183,6 +189,126 @@ async function configureApp(
             }
           }
         }
+
+        // ***** Custom logic for verification of local static path for APPs *****
+        let downloadIsNeaded = true;
+        localAppsFolder = await getLocalAppsFolder();
+        let localFile;
+        let lockFile = '';
+        const waitingTime = 1000;
+        const maxAttemptsCount = Number(process.env.APPIUM_APP_WAITING_TIMEOUT);
+        const maxLockFileLifetime = Number(process.env.APPIUM_MAX_LOCK_FILE_LIFETIME);
+        const appSizeCheckDisabled = Boolean(process.env.APPIUM_APP_SIZE_DISABLE?.toLowerCase?.() === 'true');
+        let appFetchRetries = Number(process.env.APPIUM_APP_FETCH_RETRIES);
+        
+        if(localAppsFolder != undefined) {
+          localFile = await getLocalFileForAppUrl(newApp);
+          lockFile = localFile + '.lock';
+
+          if(await fs.exists(localFile)) {
+            if(appSizeCheckDisabled === false) {
+              // Checking of local application actuality
+              logger.info(`[MCLOUD] Local version of app was found. Will check actuality of the file`);
+              // At this point local file might be deleted by parallel session which updates outdated app
+              let attemptsCount = 0;
+              while(!await fs.exists(localFile) && (attemptsCount++ < maxAttemptsCount)) {
+                await new Promise((resolve) => {
+                  logger.info(`[MCLOUD] Attempt #${attemptsCount} for local app file to appear again`);
+                  setTimeout(resolve, waitingTime);
+                });
+              }
+              if(!await fs.exists(localFile)) {
+                throw Error(`[MCLOUD] Local application file has not appeared after updating by parallel Appium session`);
+              }
+              const stats = await fs.stat(localFile);
+              const localFileLength = stats.size;
+              const remoteFileLength = await getFileContentLength(app);
+              logger.info(`[MCLOUD] Remote file size is ${remoteFileLength} and local file size is ${localFileLength}`);
+              if(remoteFileLength != localFileLength) {
+                logger.info(`[MCLOUD] Sizes differ. Hence that's needed to download fresh version of the app`);
+                if (await fs.exists(localFile)) {
+                  await fs.unlink(localFile);
+                } else {
+                  logger.warn(`[MCLOUD] Old local application file ${localFile} was not found. Probably it was removed by another thread which was downloading app in parallel`);
+                }
+                downloadIsNeaded = true;
+              } else {
+                logger.info(`[MCLOUD] Sizes are the same. Hence will use already stored application for the session`);
+                newApp = localFile;
+                shouldUnzipApp = ZIP_EXTS.has(path.extname(newApp));
+                downloadIsNeaded = false;
+              }
+            } else {
+              logger.info(`[MCLOUD] APPIUM_APP_SIZE_DISABLE=true hence skipping file size checking and going to use found file as application source`);
+              newApp = localFile;
+              shouldUnzipApp = ZIP_EXTS.has(path.extname(newApp));
+              downloadIsNeaded = false;
+            }
+          } else if (await fs.exists(lockFile)) {
+            logger.info(`[MCLOUD] Local version of app not found but .lock file exists. Waiting for .lock to disappear`);
+            logger.info(`[MCLOUD] .lock file parameters. Ð¡reated time: ${(await fs.stat(lockFile)).ctime.toLocaleString('en-US', { timeZoneName: 'short' })}; device/session details: ${await fs.readFile(lockFile, 'utf8')}`);
+            // Wait for some time till App is downloaded by some parallel Appium instance
+            let attemptsCount = 0;
+            while(await fs.exists(lockFile) && (attemptsCount++ < maxAttemptsCount)) {
+              const stats = await fs.stat(lockFile);
+              var diffInSeconds = (new Date().getTime() - stats.ctime.getTime()) / 1000;
+
+              if (diffInSeconds >= maxLockFileLifetime) {
+                logger.info(`[MCLOUD] Removing .lock file since its lifetime reached to the limit`);
+                if (await fs.exists(lockFile)) {
+                  await fs.unlink(lockFile);
+                  throw Error(`[MCLOUD] .lock file was removed due to lifetime limit. New download attempt will start for the next session request`);
+                } else {
+                  logger.warn(`[MCLOUD] Lock file ${lockFile} was not found. Probably it was removed by another thread which was downloading app in parallel`);
+                }
+              }
+
+              await new Promise((resolve) => {
+                logger.info(`[MCLOUD] Attempt #${attemptsCount} for .lock file checking`);
+                setTimeout(resolve, waitingTime);
+              });
+            }
+            if(await fs.exists(lockFile)) {
+              throw Error(`[MCLOUD] .lock file for downloading application has not disappeared after ${waitingTime * maxAttemptsCount}ms`);
+            }
+            if(!await fs.exists(localFile)) {
+              throw Error(`[MCLOUD] Local application file has not appeared after .lock file removal`);
+            }
+            logger.info(`[MCLOUD] Local version of app was found after .lock file removal. Will use it for new session`);
+            newApp = localFile;
+            shouldUnzipApp = ZIP_EXTS.has(path.extname(newApp));
+            downloadIsNeaded = false;
+          } else {
+            logger.info(`[MCLOUD] Neither local version of app nor .lock file was found. Will download app from remote URL.`);
+            downloadIsNeaded = true;
+          }
+        } else {
+          logger.info(`[MCLOUD] Local apps folder is not defined via environment properties, hence skipping this logic. Use variable APPIUM_APPS_DIR for path setting`);
+        }
+        if(downloadIsNeaded) {
+        
+          if(localAppsFolder != undefined) {
+            logger.info(`[MCLOUD] Local version of app was not found. Hence using default Appium logic for downloading`);
+            const sharedFolderPath = await getSharedFolderForAppUrl(app);
+            logger.info(`[MCLOUD] Folder for local shared apps: ${sharedFolderPath}`);
+            // @ts-ignore
+            await fs.close(await fs.open(lockFile, 'w'));
+            var sessionId = process.env.sessionId;
+            var deviceId = process.env.DEVICE_UDID;
+            if(sessionId === undefined) {
+              sessionId = "could not define session ID";
+            }
+            if(deviceId === undefined) {
+              deviceId = "could not define device UUID";
+            }
+            var msg = `device UUID: ${deviceId}, session ID: ${sessionId}`;
+            logger.info(`[MCLOUD] session/device info: ${msg}`);
+            await fs.writeFile(lockFile, msg);
+            logger.info(`[MCLOUD] lock file was written successfully`);
+          }
+
+          try {
+
         if (cachedAppInfo && status === HTTP_STATUS_NOT_MODIFIED) {
           if (await isAppIntegrityOk(cachedAppInfo.fullPath, cachedAppInfo.integrity)) {
             logger.info(`Reusing previously downloaded application at '${cachedAppInfo.fullPath}'`);
@@ -255,7 +381,37 @@ async function configureApp(
           prefix: fileName,
           suffix: '',
         });
-        newApp = await fetchApp(stream, targetPath);
+        while(appFetchRetries-- >= 0 && !(await fs.exists(newApp)))
+        {
+          try {
+            logger.info(`[MCLOUD] Going to fetch remote app`);
+            newApp = await fetchApp(stream, targetPath);
+          } catch (err) {
+            logger.error(`[MCLOUD] Error during fetching of the application ${err.message}. Attempts left ${appFetchRetries}`);
+          }
+        }
+          
+
+        // ***** Custom logic for copying of downloaded app to static location *****
+        if(localAppsFolder != undefined) {
+          logger.info(`[MCLOUD] New app path: ${newApp}`);
+          // @ts-ignore
+          await fs.copyFile(newApp, localFile);
+        }
+        }
+        finally {
+          if(localAppsFolder != undefined) {
+            logger.info(`[MCLOUD] Going to remove lock file ${lockFile}`)
+            // @ts-ignore
+            if (await fs.exists(lockFile)) {
+              // @ts-ignore
+              await fs.unlink(lockFile);
+            } else {
+              logger.warn(`[MCLOUD] Lock file ${lockFile} was not found. Probably it was removed by another thread which was downloading app in parallel`);
+            }
+          }
+        }
+        }
       } finally {
         if (!stream.closed) {
           stream.destroy();
@@ -286,7 +442,8 @@ async function configureApp(
       if (packageHash === cachedAppInfo?.packageHash) {
         const fullPath = cachedAppInfo?.fullPath;
         if (await isAppIntegrityOk(fullPath, cachedAppInfo?.integrity)) {
-          if (archivePath !== app) {
+          if (archivePath !== app && localAppsFolder === undefined) {
+            logger.info(`[MCLOUD] isAppIntegrityOk=true. Deleting files by path: ${archivePath}`);
             await fs.rimraf(archivePath);
           }
           logger.info(`Will reuse previously cached application at '${fullPath}'`);
@@ -302,7 +459,8 @@ async function configureApp(
       try {
         newApp = await unzipApp(archivePath, tmpRoot, supportedAppExtensions);
       } finally {
-        if (newApp !== archivePath && archivePath !== app) {
+        if (newApp !== archivePath && archivePath !== app && localAppsFolder === undefined) {
+          logger.info(`[MCLOUD] Remove after unzipApp(). Deleting files by path: ${archivePath}`);
           await fs.rimraf(archivePath);
         }
       }
@@ -318,7 +476,10 @@ async function configureApp(
 
     const storeAppInCache = async (appPathToCache) => {
       const cachedFullPath = cachedAppInfo?.fullPath;
-      if (cachedFullPath && cachedFullPath !== appPathToCache) {
+      // [MCLOUD] We control actuality of the file in custom logic.
+      // so no need to remove file phisically from shared location when updating Appium cache.
+      if (cachedFullPath && cachedFullPath !== appPathToCache && localAppsFolder === undefined) {
+        logger.info(`[MCLOUD] storeAppInCache(). Deleting files by path: ${cachedFullPath}`);
         await fs.rimraf(cachedFullPath);
       }
       const integrity = {};
@@ -514,6 +675,7 @@ async function unzipApp(zipPath, dstRoot, supportedAppExtensions) {
     await fs.mv(path.resolve(tmpRoot, matchedBundle), dstPath, {mkdirp: true});
     return dstPath;
   } finally {
+    logger.info(`[MCLOUD] unzipApp(). Deleting files by path: ${tmpRoot}`);
     await fs.rimraf(tmpRoot);
   }
 }
diff --git a/packages/base-driver/lib/basedriver/mcloud-utils.ts b/packages/base-driver/lib/basedriver/mcloud-utils.ts
new file mode 100644
index 000000000..b045d4c0f
--- /dev/null
+++ b/packages/base-driver/lib/basedriver/mcloud-utils.ts
@@ -0,0 +1,136 @@
+import {fs} from '@appium/support';
+import nodePath from 'path';
+import axios from 'axios';
+import path from 'path';
+import logger from './logger';
+import util from 'util';
+import { exec } from 'child_process';
+import {
+    type ResponseType
+  } from 'axios';
+
+async function getLocalAppsFolder() {
+    if(process.env.APPIUM_APPS_DIR === undefined || process.env.APPIUM_APPS_DIR === '')
+        return undefined;
+    else
+        return process.env.APPIUM_APPS_DIR;
+}
+
+async function getSharedFolderForAppUrl(url) {
+    const sub = await getLocalFileForAppUrl(url);
+
+    const lastSlashInd = sub.lastIndexOf(path.sep);
+    var targetPath;
+    if(lastSlashInd != -1) {
+        targetPath = sub.substring(0, lastSlashInd);
+    } else {
+        targetPath = '';
+    }
+
+    logger.info(`[MCLOUD] Target path [getSharedFolderForAppUrl]: ${targetPath}`)
+    const folderExists = await fs.exists(targetPath);
+    if(!folderExists)
-        await fs.mkdir(targetPath, {recursive : true});
+        await support_1.fs.mkdir(targetPath, {recursive : true});
+    return targetPath;
+}
+exports.getSharedFolderForAppUrl = getSharedFolderForAppUrl;
+async function getLocalFileForAppUrl(url) {
+    var sub = url.substring(url.indexOf('//') + 2)
+    sub = sub.substring(sub.indexOf('/'));
+    if(sub.includes('?')) {
+        sub = sub.substring(0, sub.indexOf('?'));
+    }
+    sub = sub.replace(/\//g, path.sep);
+
+    const targetPath = nodePath.join(await getLocalAppsFolder() as string, sub);
+    logger.info(`[MCLOUD] Target path [getLocalFileForAppUrl]: ${targetPath}`)
+    return targetPath;
+}
+
+async function getFileContentLength(remoteUrl) {
+    const timeout = 10000;
+    const retries = 5;
+    const pollingInterval = 3000;
+
+    const requestOpts = {
+        url: remoteUrl,
+        responseType: 'stream' as ResponseType,
+        timeout: timeout,
+    };
+
+    // getting content-length with retry
+    var lastError;
+    const getLengthRequest = async () => {
+        for (var i=0; i<retries; i++) {
+            try {
+                logger.debug(`[MCLOUD] Making GET http call for retrieving of remote app size`);
+                const {
+                    headers: responseHeaders,
+                } = await axios(requestOpts);
+                const responseLength = parseInt(responseHeaders['content-length'], 10);
+                logger.debug(`[MCLOUD] CONTENT-LENGTH for the file: ${responseLength}`);
+                return responseLength;
+            } catch (error) {
+                lastError = error;
+                console.log(`[MCLOUD] Cannot fetch info about app size. Will retry attempt in ${pollingInterval}ms`);
+                await new Promise(resolve => setTimeout(resolve, pollingInterval));
+            }
+        }
+    }
+    const length = await getLengthRequest();
+    if(length) {
+        return length;
+    } else {
+        throw new Error(`[MCLOUD] Cannot get file content-length from ${remoteUrl} after ${retries} retry(s): ${lastError}`);
+    }
+}
+
+function executeShell(shellCommand, description) {
+    exec(shellCommand, (error, stdout, stderr) => {
+        if (error) {
+            logger.info(`[MCLOUD] ${description} error: ${error.message}`);
+            return;
+        }
+        if (stderr) {
+            logger.info(`[MCLOUD] ${description} stderr: ${stderr}`);
+            return;
+        }
+        logger.info(`[MCLOUD] ${description} command was successfully executed`);
+      });
+}
+
+async function executeShellWPromise(shellCommand) {
+    const execPromisify = util.promisify(exec);
+    return await execPromisify(shellCommand);
+}
+
+async function parseWDAUrl() {
+    const wdaHost = process.env.WDA_HOST;
+    const wdaPort = process.env.WDA_PORT;
+    return `http://${wdaHost}:${wdaPort}/status`;
+}
+
+async function getWDAStatus(wdaURL) {
+    try {
+        return (await axios({
+          url: wdaURL,
+          method: 'GET',
+          timeout: 500,
+        })).data;
+      } catch (e) {
+        logger.info(`Cannot send GET request to '${wdaURL}'. Original error: ${e.message}`);
+        return undefined;
+      }
+}
+
+export {
+    getLocalAppsFolder,
+    getSharedFolderForAppUrl,
+    getLocalFileForAppUrl,
+    getFileContentLength,
+    executeShell,
+    executeShellWPromise,
+    parseWDAUrl,
+    getWDAStatus
+}
\ No newline at end of file
diff --git a/packages/base-driver/lib/protocol/protocol.js b/packages/base-driver/lib/protocol/protocol.js
index 7eca78cd9..4f8034cad 100644
--- a/packages/base-driver/lib/protocol/protocol.js
+++ b/packages/base-driver/lib/protocol/protocol.js
@@ -458,6 +458,9 @@ function buildHandler(app, method, path, spec, driver, isSessCmd) {
           })}`
       );
     } catch (err) {
      // PATCH #2 <appium>/node_modules/appium/node_modules/appium-base-driver/build/lib/protocol/protocol.js to return to carina "DEBUG info" about problematic step
-     err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
+     if(err.message !== 'An element could not be located on the page using the given search parameters.'){
+         err.message = `${err.message}[[[--udid ${process.env.DEVICE_UDID} --name ${process.env.DEVICE_NAME} --sessionId ${process.env.sessionId}]]]`;
+     }
+
+      // handling error with Cannot find any free port in range
+      if (err.message.toLowerCase().includes("cannot find any free port in range")) {
+            console.log(`Cannot find any free port in range. Error message: ${err.message} Appium exit with code 1 `);
+            // Exiting with code 1 to indicate an error
+            process.exit(1);
+      }
+
+      // handling error with ENOSPC: no space left on device, mkdir '/tmp/ and exit with code 0
+      if(err.message.toLowerCase().includes('no space left on device') || err.message.toLowerCase().includes('adb: failed to install')){
+           console.log(`- [BaseDriver] ENOSPC error, no space left on device, Error message:${err.message} appium exit with code 0`)
+           process.exit(0);
+      }
+            
+      // Check if the error 'socket hang up' occurred and do exit 0 
+      if (err.message.toLowerCase().includes("socket hang up") && err.message.toLowerCase().includes("could not proxy command to the remote server")) {
+           console.log(`- [BaseDriver] Error occurred, socket hang up. Original error: ${err.message} Appium exit with code 0`);
+           process.exit(0);
+      }
+
+       // Check if the error 'device setup is not yet complete' occurred and do exit 1 
+       if (err.message.toLowerCase().includes("device setup is not yet complete")) {
+           console.log(`- [BaseDriver] Error occurred, device setup is not yet complete. Original error: ${err.message} Appium exit with code 0`);
+           process.exit(0);
+       }
+
+       // Check if the error is related to executing the 'am' shell command and do exit code 0
+       if (err.message.toLowerCase().includes("Ñannot execute the 'am' shell command")) {
+           console.log(`- [BaseDriver] Got error: Cannot execute the 'am' shell command. Error message: ${err.message} Appium exit with code 0`);
+           process.exit(0);
+       }

             let actualErr;


diff --git a/packages/base-driver/lib/protocol/routes.js b/packages/base-driver/lib/protocol/routes.js
index 23eacf31c..b810855b6 100644
--- a/packages/base-driver/lib/protocol/routes.js
+++ b/packages/base-driver/lib/protocol/routes.js
@@ -24,6 +24,12 @@ const METHOD_MAP = /** @type {const} */ ({
   '/status': {
     GET: {command: 'getStatus'},
   },
+  '/status-wda': {
+    GET: {command: 'getStatusWDA', payloadParams: {optional: ['exitCode']}}
+  },
+  '/status-adb': {
+    GET: {command: 'getStatusADB', payloadParams: {optional: ['exitCode']}}
+  },
   '/session': {
     POST: {
       command: 'createSession',
@@ -1002,6 +1008,6 @@ function routeToCommandName(endpoint, method, basePath = DEFAULT_BASE_PATH) {
 }
 
 // driver commands that do not require a session to already exist
-const NO_SESSION_ID_COMMANDS = ['createSession', 'getStatus', 'getSessions'];
+const NO_SESSION_ID_COMMANDS = ['createSession', 'getStatus', 'getStatusWDA', 'getStatusADB', 'getSessions'];
 
 export {METHOD_MAP, ALL_COMMANDS, NO_SESSION_ID_COMMANDS, routeToCommandName};
diff --git a/packages/execute-driver-plugin/lib/plugin.js b/packages/execute-driver-plugin/lib/plugin.js
index 66845d34e..e3974d2dc 100644
--- a/packages/execute-driver-plugin/lib/plugin.js
+++ b/packages/execute-driver-plugin/lib/plugin.js
@@ -1,3 +1,4 @@
+// @ts-nocheck
 import {BasePlugin} from 'appium/plugin';
 import _ from 'lodash';
 import cp from 'child_process';
